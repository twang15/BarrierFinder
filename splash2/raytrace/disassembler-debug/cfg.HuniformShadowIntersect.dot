digraph "CFG for 'HuniformShadowIntersect' function" {
	label="CFG for 'HuniformShadowIntersect' function";

	Node0x5f6a280 [shape=record,label="{entry:\l  %retval = alloca double, align 8\l  %r.addr = alloca %struct.ray*, align 8\l  %lightlength.addr = alloca double, align 8\l  %pe.addr = alloca %struct.element*, align 8\l  %pid.addr = alloca i64, align 8\l  %status = alloca i64, align 8\l  %hitcode = alloca i64, align 8\l  %i = alloca i64, align 8\l  %trans = alloca double, align 8\l  %peParent = alloca %struct.object*, align 8\l  %pptr = alloca %struct.element**, align 8\l  %pe2 = alloca %struct.element*, align 8\l  %newhit = alloca [2 x %struct.irecord], align 16\l  %v = alloca %struct.voxel*, align 8\l  store %struct.ray* %r, %struct.ray** %r.addr, align 8\l  store double %lightlength, double* %lightlength.addr, align 8\l  store %struct.element* %pe, %struct.element** %pe.addr, align 8\l  store double 1.000000e+00, double* %trans, align 8\l  %0 = load %struct.ray** %r.addr, align 8\l  %ri = getelementptr inbounds %struct.ray* %0, i32 0, i32 8\l  store %struct.rayinfo* null, %struct.rayinfo** %ri, align 8\l  %1 = load %struct.ray** %r.addr, align 8\l  %2 = load %struct.gmem** @gm, align 8\l  %world_level_grid = getelementptr inbounds %struct.gmem* %2, i32 0, i32 4\l  %3 = load %struct.grid** %world_level_grid, align 8\l  %call = call %struct.voxel* @init_ray(%struct.ray* %1, %struct.grid* %3)\l  store %struct.voxel* %call, %struct.voxel** %v, align 8\l  %4 = load %struct.voxel** %v, align 8\l  %cmp = icmp eq %struct.voxel* %4, null\l  br i1 %cmp, label %if.then, label %if.end\l|{<s0>T|<s1>F}}"];
	Node0x5f6a280:s0 -> Node0x5f6a2d0;
	Node0x5f6a280:s1 -> Node0x5f6a320;
	Node0x5f6a2d0 [shape=record,label="{if.then:                                          \l  %5 = load %struct.ray** %r.addr, align 8\l  call void @reset_rayinfo(%struct.ray* %5)\l  %6 = load double* %trans, align 8\l  store double %6, double* %retval\l  br label %return\l}"];
	Node0x5f6a2d0 -> Node0x5f6a8c0;
	Node0x5f6a320 [shape=record,label="{if.end:                                           \l  %arrayidx = getelementptr inbounds [2 x %struct.irecord]* %newhit, i32 0,\l... i64 0\l  %t = getelementptr inbounds %struct.irecord* %arrayidx, i32 0, i32 0\l  store double 1.000000e+32, double* %t, align 8\l  store i64 2, i64* %status, align 8\l  br label %while.cond\l}"];
	Node0x5f6a320 -> Node0x5f6a370;
	Node0x5f6a370 [shape=record,label="{while.cond:                                       \l  %7 = load double* %trans, align 8\l  %cmp1 = fcmp ogt double %7, 0.000000e+00\l  br i1 %cmp1, label %land.rhs, label %land.end\l|{<s0>T|<s1>F}}"];
	Node0x5f6a370:s0 -> Node0x5f6a3c0;
	Node0x5f6a370:s1 -> Node0x5f6a410;
	Node0x5f6a3c0 [shape=record,label="{land.rhs:                                         \l  %8 = load i64* %status, align 8\l  %cmp2 = icmp ne i64 %8, 0\l  br label %land.end\l}"];
	Node0x5f6a3c0 -> Node0x5f6a410;
	Node0x5f6a410 [shape=record,label="{land.end:                                         \l  %9 = phi i1 [ false, %while.cond ], [ %cmp2, %land.rhs ]\l  br i1 %9, label %while.body, label %while.end\l|{<s0>T|<s1>F}}"];
	Node0x5f6a410:s0 -> Node0x5f6a460;
	Node0x5f6a410:s1 -> Node0x5f6a870;
	Node0x5f6a460 [shape=record,label="{while.body:                                       \l  %10 = load %struct.voxel** %v, align 8\l  %cell = getelementptr inbounds %struct.voxel* %10, i32 0, i32 1\l  %11 = load i8** %cell, align 8\l  %12 = bitcast i8* %11 to %struct.element**\l  store %struct.element** %12, %struct.element*** %pptr, align 8\l  store i64 0, i64* %i, align 8\l  br label %for.cond\l}"];
	Node0x5f6a460 -> Node0x5f6a4b0;
	Node0x5f6a4b0 [shape=record,label="{for.cond:                                         \l  %13 = load i64* %i, align 8\l  %14 = load %struct.voxel** %v, align 8\l  %numelements = getelementptr inbounds %struct.voxel* %14, i32 0, i32 3\l  %15 = load i64* %numelements, align 8\l  %cmp3 = icmp slt i64 %13, %15\l  br i1 %cmp3, label %land.rhs.4, label %land.end.6\l|{<s0>T|<s1>F}}"];
	Node0x5f6a4b0:s0 -> Node0x5f6a500;
	Node0x5f6a4b0:s1 -> Node0x5f6a550;
	Node0x5f6a500 [shape=record,label="{land.rhs.4:                                       \l  %16 = load double* %trans, align 8\l  %cmp5 = fcmp ogt double %16, 0.000000e+00\l  br label %land.end.6\l}"];
	Node0x5f6a500 -> Node0x5f6a550;
	Node0x5f6a550 [shape=record,label="{land.end.6:                                       \l  %17 = phi i1 [ false, %for.cond ], [ %cmp5, %land.rhs.4 ]\l  br i1 %17, label %for.body, label %for.end\l|{<s0>T|<s1>F}}"];
	Node0x5f6a550:s0 -> Node0x5f6a5a0;
	Node0x5f6a550:s1 -> Node0x5f6a780;
	Node0x5f6a5a0 [shape=record,label="{for.body:                                         \l  %18 = load i64* %i, align 8\l  %19 = load %struct.element*** %pptr, align 8\l  %arrayidx7 = getelementptr inbounds %struct.element** %19, i64 %18\l  %20 = load %struct.element** %arrayidx7, align 8\l  store %struct.element* %20, %struct.element** %pe2, align 8\l  %21 = load %struct.element** %pe2, align 8\l  %parent = getelementptr inbounds %struct.element* %21, i32 0, i32 2\l  %22 = load %struct.object** %parent, align 8\l  store %struct.object* %22, %struct.object** %peParent, align 8\l  %23 = load %struct.object** %peParent, align 8\l  %procs = getelementptr inbounds %struct.object* %23, i32 0, i32 5\l  %24 = load %struct.pprocs** %procs, align 8\l  %pe_intersect = getelementptr inbounds %struct.pprocs* %24, i32 0, i32 6\l  %25 = load i64 (...)** %pe_intersect, align 8\l  %callee.knr.cast = bitcast i64 (...)* %25 to i64 (%struct.ray*,\l... %struct.element*, %struct.irecord*, ...)*\l  %call8 = call i64 (%struct.ray*, %struct.element*, %struct.irecord*, ...)\l... *%callee.knr.cast(%struct.ray* undef, %struct.element* undef,\l... %struct.irecord* undef)\l  store i64 %call8, i64* %hitcode, align 8\l  %26 = load i64* %hitcode, align 8\l  %tobool = icmp ne i64 %26, 0\l  br i1 %tobool, label %land.lhs.true, label %if.end.19\l|{<s0>T|<s1>F}}"];
	Node0x5f6a5a0:s0 -> Node0x5f6a5f0;
	Node0x5f6a5a0:s1 -> Node0x5f6a6e0;
	Node0x5f6a5f0 [shape=record,label="{land.lhs.true:                                    \l  %arrayidx9 = getelementptr inbounds [2 x %struct.irecord]* %newhit, i32 0,\l... i64 0\l  %pelem = getelementptr inbounds %struct.irecord* %arrayidx9, i32 0, i32 1\l  %27 = load %struct.element** %pelem, align 8\l  %28 = load %struct.element** %pe.addr, align 8\l  %cmp10 = icmp ne %struct.element* %27, %28\l  br i1 %cmp10, label %land.lhs.true.11, label %if.end.19\l|{<s0>T|<s1>F}}"];
	Node0x5f6a5f0:s0 -> Node0x5f6a640;
	Node0x5f6a5f0:s1 -> Node0x5f6a6e0;
	Node0x5f6a640 [shape=record,label="{land.lhs.true.11:                                 \l  %arrayidx12 = getelementptr inbounds [2 x %struct.irecord]* %newhit, i32 0,\l... i64 0\l  %t13 = getelementptr inbounds %struct.irecord* %arrayidx12, i32 0, i32 0\l  %29 = load double* %t13, align 8\l  %30 = load double* %lightlength.addr, align 8\l  %cmp14 = fcmp olt double %29, %30\l  br i1 %cmp14, label %if.then.15, label %if.end.19\l|{<s0>T|<s1>F}}"];
	Node0x5f6a640:s0 -> Node0x5f6a690;
	Node0x5f6a640:s1 -> Node0x5f6a6e0;
	Node0x5f6a690 [shape=record,label="{if.then.15:                                       \l  %arrayidx16 = getelementptr inbounds [2 x %struct.irecord]* %newhit, i32 0,\l... i64 0\l  %pelem17 = getelementptr inbounds %struct.irecord* %arrayidx16, i32 0, i32 1\l  %31 = load %struct.element** %pelem17, align 8\l  %parent18 = getelementptr inbounds %struct.element* %31, i32 0, i32 2\l  %32 = load %struct.object** %parent18, align 8\l  %surf = getelementptr inbounds %struct.object* %32, i32 0, i32 6\l  %33 = load %struct.surf** %surf, align 8\l  %ktran = getelementptr inbounds %struct.surf* %33, i32 0, i32 4\l  %34 = load double* %ktran, align 8\l  %35 = load double* %trans, align 8\l  %mul = fmul double %35, %34\l  store double %mul, double* %trans, align 8\l  br label %if.end.19\l}"];
	Node0x5f6a690 -> Node0x5f6a6e0;
	Node0x5f6a6e0 [shape=record,label="{if.end.19:                                        \l  br label %for.inc\l}"];
	Node0x5f6a6e0 -> Node0x5f6a730;
	Node0x5f6a730 [shape=record,label="{for.inc:                                          \l  %36 = load i64* %i, align 8\l  %inc = add nsw i64 %36, 1\l  store i64 %inc, i64* %i, align 8\l  br label %for.cond\l}"];
	Node0x5f6a730 -> Node0x5f6a4b0;
	Node0x5f6a780 [shape=record,label="{for.end:                                          \l  %37 = load double* %trans, align 8\l  %cmp20 = fcmp ogt double %37, 0.000000e+00\l  br i1 %cmp20, label %if.then.21, label %if.end.23\l|{<s0>T|<s1>F}}"];
	Node0x5f6a780:s0 -> Node0x5f6a7d0;
	Node0x5f6a780:s1 -> Node0x5f6a820;
	Node0x5f6a7d0 [shape=record,label="{if.then.21:                                       \l  %38 = load %struct.ray** %r.addr, align 8\l  %call22 = call %struct.voxel* @next_nonempty_leaf(%struct.ray* %38, i64 1,\l... i64* %status)\l  store %struct.voxel* %call22, %struct.voxel** %v, align 8\l  br label %if.end.23\l}"];
	Node0x5f6a7d0 -> Node0x5f6a820;
	Node0x5f6a820 [shape=record,label="{if.end.23:                                        \l  br label %while.cond\l}"];
	Node0x5f6a820 -> Node0x5f6a370;
	Node0x5f6a870 [shape=record,label="{while.end:                                        \l  %39 = load %struct.ray** %r.addr, align 8\l  call void @reset_rayinfo(%struct.ray* %39)\l  %40 = load double* %trans, align 8\l  store double %40, double* %retval\l  br label %return\l}"];
	Node0x5f6a870 -> Node0x5f6a8c0;
	Node0x5f6a8c0 [shape=record,label="{return:                                           \l  %41 = load double* %retval\l  ret double %41\l}"];
}

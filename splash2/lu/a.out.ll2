; ModuleID = 'LU.opt.bc'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.GlobalMemory = type { double*, double*, double*, double*, double*, i32, i32, i32, i32, i32, %struct.barrier_t, %union.pthread_mutex_t }
%struct.barrier_t = type { i32, i64 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { %struct.__pthread_internal_list*, %struct.__pthread_internal_list* }
%union.pthread_attr_t = type { i64, [48 x i8] }
%union.pthread_mutexattr_t = type { i32 }
%struct.LocalCopies = type { double, double, double, double }

@n = internal global i32 1, align 4
@P = internal global i32 2, align 4
@block_size = internal global i32 16, align 4
@test_result = internal global i32 0, align 4
@doprint = internal global i32 0, align 4
@dostats = internal global i32 0, align 4
@optarg = external global i8*, align 8
@num_rows = internal global i32 0, align 4
@num_cols = internal global i32 0, align 4
@nblocks = internal global i32 0, align 4
@proc_bytes = internal global i32* null, align 8
@last_malloc = internal global double** null, align 8
@stderr = external global %struct._IO_FILE*, align 8
@a = internal global double** null, align 8
@rhs = internal global double* null, align 8
@Global = internal global %struct.GlobalMemory* null, align 8
@stdout = external global %struct._IO_FILE*, align 8
@.str = private unnamed_addr constant [12 x i8] c"n:p:b:cstoh\00", align 1
@.str.1 = private unnamed_addr constant [22 x i8] c"Usage: LU <options>\0A\0A\00", align 1
@.str.2 = private unnamed_addr constant [10 x i8] c"options:\0A\00", align 1
@.str.3 = private unnamed_addr constant [31 x i8] c"  -nN : Decompose NxN matrix.\0A\00", align 1
@.str.4 = private unnamed_addr constant [35 x i8] c"  -pP : P = number of processors.\0A\00", align 1
@.str.5 = private unnamed_addr constant [70 x i8] c"  -bB : Use a block size of B. BxB elements should fit in cache for \0A\00", align 1
@.str.6 = private unnamed_addr constant [68 x i8] c"        good performance. Small block sizes (B=8, B=16) work well.\0A\00", align 1
@.str.7 = private unnamed_addr constant [71 x i8] c"  -c  : Copy non-locally allocated blocks to local memory before use.\0A\00", align 1
@.str.8 = private unnamed_addr constant [55 x i8] c"  -s  : Print individual processor timing statistics.\0A\00", align 1
@.str.9 = private unnamed_addr constant [22 x i8] c"  -t  : Test output.\0A\00", align 1
@.str.10 = private unnamed_addr constant [34 x i8] c"  -o  : Print out matrix values.\0A\00", align 1
@.str.11 = private unnamed_addr constant [42 x i8] c"  -h  : Print out command line options.\0A\0A\00", align 1
@.str.12 = private unnamed_addr constant [31 x i8] c"Default: LU -n%1d -p%1d -b%1d\0A\00", align 1
@.str.13 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.14 = private unnamed_addr constant [32 x i8] c"Blocked Dense LU Factorization\0A\00", align 1
@.str.15 = private unnamed_addr constant [22 x i8] c"     %d by %d Matrix\0A\00", align 1
@.str.16 = private unnamed_addr constant [20 x i8] c"     %d Processors\0A\00", align 1
@.str.17 = private unnamed_addr constant [30 x i8] c"     %d by %d Element Blocks\0A\00", align 1
@.str.18 = private unnamed_addr constant [44 x i8] c"Could not malloc memory blocks for proc %d\0A\00", align 1
@.str.19 = private unnamed_addr constant [31 x i8] c"Could not malloc memory for a\0A\00", align 1
@.str.20 = private unnamed_addr constant [33 x i8] c"Could not malloc memory for rhs\0A\00", align 1
@.str.21 = private unnamed_addr constant [36 x i8] c"Could not malloc memory for Global\0A\00", align 1
@.str.22 = private unnamed_addr constant [46 x i8] c"Could not malloc memory for Global->t_in_fac\0A\00", align 1
@.str.23 = private unnamed_addr constant [46 x i8] c"Could not malloc memory for Global->t_in_mod\0A\00", align 1
@.str.24 = private unnamed_addr constant [48 x i8] c"Could not malloc memory for Global->t_in_solve\0A\00", align 1
@.str.25 = private unnamed_addr constant [46 x i8] c"Could not malloc memory for Global->t_in_bar\0A\00", align 1
@.str.26 = private unnamed_addr constant [48 x i8] c"Could not malloc memory for Global->completion\0A\00", align 1
@.str.27 = private unnamed_addr constant [30 x i8] c"Matrix before decomposition:\0A\00", align 1
@.str.28 = private unnamed_addr constant [30 x i8] c"\0AMatrix after decomposition:\0A\00", align 1
@.str.29 = private unnamed_addr constant [48 x i8] c"                            PROCESS STATISTICS\0A\00", align 1
@.str.30 = private unnamed_addr constant [77 x i8] c"              Total      Diagonal     Perimeter      Interior       Barrier\0A\00", align 1
@.str.31 = private unnamed_addr constant [75 x i8] c" Proc         Time         Time         Time           Time          Time\0A\00", align 1
@.str.32 = private unnamed_addr constant [57 x i8] c"    0    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\0A\00", align 1
@.str.33 = private unnamed_addr constant [57 x i8] c"  %3d    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\0A\00", align 1
@.str.34 = private unnamed_addr constant [57 x i8] c"  Avg    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\0A\00", align 1
@.str.35 = private unnamed_addr constant [57 x i8] c"  Min    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\0A\00", align 1
@.str.36 = private unnamed_addr constant [57 x i8] c"  Max    %10.0f    %10.0f    %10.0f    %10.0f    %10.0f\0A\00", align 1
@.str.37 = private unnamed_addr constant [48 x i8] c"                            TIMING INFORMATION\0A\00", align 1
@.str.38 = private unnamed_addr constant [42 x i8] c"Start time                        : %16d\0A\00", align 1
@.str.39 = private unnamed_addr constant [42 x i8] c"Initialization finish time        : %16d\0A\00", align 1
@.str.40 = private unnamed_addr constant [42 x i8] c"Overall finish time               : %16d\0A\00", align 1
@.str.41 = private unnamed_addr constant [42 x i8] c"Total time with initialization    : %16d\0A\00", align 1
@.str.42 = private unnamed_addr constant [42 x i8] c"Total time without initialization : %16d\0A\00", align 1
@.str.43 = private unnamed_addr constant [46 x i8] c"                             TESTING RESULTS\0A\00", align 1
@.str.49 = private unnamed_addr constant [11 x i8] c"ERROR: %s\0A\00", align 1
@.str.46 = private unnamed_addr constant [31 x i8] c"Could not malloc memory for y\0A\00", align 1
@.str.47 = private unnamed_addr constant [26 x i8] c"TEST FAILED: (%.5f diff)\0A\00", align 1
@.str.48 = private unnamed_addr constant [13 x i8] c"TEST PASSED\0A\00", align 1
@.str.44 = private unnamed_addr constant [40 x i8] c"Proc %d could not malloc memory for lc\0A\00", align 1
@.str.45 = private unnamed_addr constant [7 x i8] c"%8.1f \00", align 1
@index_out = internal global i32 0, align 4
@gSyncVar_0 = internal global i32 0, align 4
@gSyncVar_1 = internal global i32 0, align 4
@gSyncVar_2 = internal global i32 0, align 4
@gSyncVarsTotalNum = internal global i32 0, align 4
@counter0 = internal global i32 0, align 4
@counter1 = internal global i32 0, align 4
@firstSync = internal global i8 1, align 1
@mystring = internal global [200 x i8] zeroinitializer, align 16
@switches = internal global [3 x i8] zeroinitializer, align 1
@syncID = internal global [3 x i32] zeroinitializer, align 4

; Function Attrs: nounwind uwtable
define i32 @main(i32 %argc, i8** %argv) {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %ch = alloca i32, align 4
  %MyNum = alloca i32, align 4
  %mint = alloca double, align 8
  %maxt = alloca double, align 8
  %avgt = alloca double, align 8
  %min_fac = alloca double, align 8
  %min_solve = alloca double, align 8
  %min_mod = alloca double, align 8
  %min_bar = alloca double, align 8
  %max_fac = alloca double, align 8
  %max_solve = alloca double, align 8
  %max_mod = alloca double, align 8
  %max_bar = alloca double, align 8
  %avg_fac = alloca double, align 8
  %avg_solve = alloca double, align 8
  %avg_mod = alloca double, align 8
  %avg_bar = alloca double, align 8
  %last_page = alloca i32, align 4
  %proc_num = alloca i32, align 4
  %edge = alloca i32, align 4
  %size = alloca i32, align 4
  %start = alloca i32, align 4
  %t = alloca i64, align 8
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %entry
  %0 = load i32* %argc.addr, align 4
  %1 = load i8*** %argv.addr, align 8
  %call1 = call i32 (i32, i8**, i8*, ...) *bitcast (i32 (...)* @getopt to i32 (i32, i8**, i8*, ...)*)(i32 %0, i8** %1, i8* getelementptr inbounds ([12 x i8]* @.str, i32 0, i32 0))
  store i32 %call1, i32* %ch, align 4
  %cmp = icmp ne i32 %call1, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i32* %ch, align 4
  switch i32 %2, label %sw.epilog [
    i32 110, label %sw.bb
    i32 112, label %sw.bb.4
    i32 98, label %sw.bb.6
    i32 115, label %sw.bb.8
    i32 116, label %sw.bb.9
    i32 111, label %sw.bb.10
    i32 104, label %sw.bb.14
  ]

sw.bb:                                            ; preds = %while.body
  %3 = load i8** @optarg, align 8
  %call3 = call i32 @atoi(i8* %3)
  store i32 %call3, i32* @n, align 4
  br label %sw.epilog

sw.bb.4:                                          ; preds = %while.body
  %4 = load i8** @optarg, align 8
  %call5 = call i32 @atoi(i8* %4)
  store i32 %call5, i32* @P, align 4
  br label %sw.epilog

sw.bb.6:                                          ; preds = %while.body
  %5 = load i8** @optarg, align 8
  %call7 = call i32 @atoi(i8* %5)
  store i32 %call7, i32* @block_size, align 4
  br label %sw.epilog

sw.bb.8:                                          ; preds = %while.body
  store i32 1, i32* @dostats, align 4
  br label %sw.epilog

sw.bb.9:                                          ; preds = %while.body
  br label %sw.epilog

sw.bb.10:                                         ; preds = %while.body
  %6 = load i32* @doprint, align 4
  %tobool11 = icmp ne i32 %6, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  store i32 %lnot.ext13, i32* @doprint, align 4
  br label %sw.epilog

sw.bb.14:                                         ; preds = %while.body
  br label %UnifiedUnreachableBlock

sw.epilog:                                        ; preds = %sw.bb.10, %sw.bb.9, %sw.bb.8, %sw.bb.6, %sw.bb.4, %sw.bb, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %7 = load i32* @P, align 4
  %conv34 = sitofp i32 %7 to double
  %call35 = call double @sqrt(double %conv34)
  %conv36 = fptosi double %call35 to i32
  store i32 %conv36, i32* @num_rows, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end, %while.end
  %8 = load i32* @P, align 4
  %9 = load i32* @num_rows, align 4
  %div = sdiv i32 %8, %9
  store i32 %div, i32* @num_cols, align 4
  %10 = load i32* @num_rows, align 4
  %11 = load i32* @num_cols, align 4
  %mul = mul nsw i32 %10, %11
  %12 = load i32* @P, align 4
  %cmp37 = icmp eq i32 %mul, %12
  br i1 %cmp37, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  %13 = load i32* @num_rows, align 4
  %dec = add nsw i32 %13, -1
  store i32 %dec, i32* @num_rows, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then
  %14 = load i32* @n, align 4
  %15 = load i32* @block_size, align 4
  %div39 = sdiv i32 %14, %15
  store i32 %div39, i32* @nblocks, align 4
  %16 = load i32* @block_size, align 4
  %17 = load i32* @nblocks, align 4
  %mul40 = mul nsw i32 %16, %17
  %18 = load i32* @n, align 4
  %cmp41 = icmp ne i32 %mul40, %18
  br i1 %cmp41, label %if.then.43, label %if.end.44

if.then.43:                                       ; preds = %for.end
  %19 = load i32* @nblocks, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, i32* @nblocks, align 4
  br label %if.end.44

if.end.44:                                        ; preds = %if.then.43, %for.end
  %20 = load i32* @n, align 4
  %21 = load i32* @block_size, align 4
  %rem = srem i32 %20, %21
  store i32 %rem, i32* %edge, align 4
  %22 = load i32* %edge, align 4
  %cmp45 = icmp eq i32 %22, 0
  br i1 %cmp45, label %if.then.47, label %if.end.48

if.then.47:                                       ; preds = %if.end.44
  %23 = load i32* @block_size, align 4
  store i32 %23, i32* %edge, align 4
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.47, %if.end.44
  %24 = load i32* @P, align 4
  %conv49 = sext i32 %24 to i64
  %mul50 = mul i64 %conv49, 4
  %call51 = call noalias i8* @malloc(i64 %mul50)
  %25 = bitcast i8* %call51 to i32*
  store i32* %25, i32** @proc_bytes, align 8
  %26 = load i32* @P, align 4
  %conv52 = sext i32 %26 to i64
  %mul53 = mul i64 %conv52, 8
  %call54 = call noalias i8* @malloc(i64 %mul53)
  %27 = bitcast i8* %call54 to double**
  store double** %27, double*** @last_malloc, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond.55

for.cond.55:                                      ; preds = %for.inc, %if.end.48
  %28 = load i32* %i, align 4
  %29 = load i32* @P, align 4
  %cmp56 = icmp slt i32 %28, %29
  br i1 %cmp56, label %for.body, label %for.end.61

for.body:                                         ; preds = %for.cond.55
  %30 = load i32* %i, align 4
  %idxprom = sext i32 %30 to i64
  %31 = load i32** @proc_bytes, align 8
  %arrayidx = getelementptr inbounds i32* %31, i64 %idxprom
  store i32 0, i32* %arrayidx, align 4
  %32 = load i32* %i, align 4
  %idxprom58 = sext i32 %32 to i64
  %33 = load double*** @last_malloc, align 8
  %arrayidx59 = getelementptr inbounds double** %33, i64 %idxprom58
  store double* null, double** %arrayidx59, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %34 = load i32* %i, align 4
  %inc60 = add nsw i32 %34, 1
  store i32 %inc60, i32* %i, align 4
  br label %for.cond.55

for.end.61:                                       ; preds = %for.cond.55
  store i32 0, i32* %i, align 4
  br label %for.cond.62

for.cond.62:                                      ; preds = %for.inc.99, %for.end.61
  %35 = load i32* %i, align 4
  %36 = load i32* @nblocks, align 4
  %cmp63 = icmp slt i32 %35, %36
  br i1 %cmp63, label %for.body.65, label %for.end.101

for.body.65:                                      ; preds = %for.cond.62
  store i32 0, i32* %j, align 4
  br label %for.cond.66

for.cond.66:                                      ; preds = %for.inc.96, %for.body.65
  %37 = load i32* %j, align 4
  %38 = load i32* @nblocks, align 4
  %cmp67 = icmp slt i32 %37, %38
  br i1 %cmp67, label %for.body.69, label %for.end.98

for.body.69:                                      ; preds = %for.cond.66
  %39 = load i32* %i, align 4
  %40 = load i32* %j, align 4
  %call70 = call i32 @BlockOwner(i32 %39, i32 %40)
  store i32 %call70, i32* %proc_num, align 4
  %41 = load i32* %i, align 4
  %42 = load i32* @nblocks, align 4
  %sub = sub nsw i32 %42, 1
  %cmp71 = icmp eq i32 %41, %sub
  br i1 %cmp71, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body.69
  %43 = load i32* %j, align 4
  %44 = load i32* @nblocks, align 4
  %sub73 = sub nsw i32 %44, 1
  %cmp74 = icmp eq i32 %43, %sub73
  br i1 %cmp74, label %if.then.76, label %if.else

if.then.76:                                       ; preds = %land.lhs.true
  %45 = load i32* %edge, align 4
  %46 = load i32* %edge, align 4
  %mul77 = mul nsw i32 %45, %46
  store i32 %mul77, i32* %size, align 4
  br label %if.end.89

if.else:                                          ; preds = %land.lhs.true, %for.body.69
  %47 = load i32* %i, align 4
  %48 = load i32* @nblocks, align 4
  %sub78 = sub nsw i32 %48, 1
  %cmp79 = icmp eq i32 %47, %sub78
  br i1 %cmp79, label %if.then.84, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %49 = load i32* %j, align 4
  %50 = load i32* @nblocks, align 4
  %sub81 = sub nsw i32 %50, 1
  %cmp82 = icmp eq i32 %49, %sub81
  br i1 %cmp82, label %if.then.84, label %if.else.86

if.then.84:                                       ; preds = %lor.lhs.false, %if.else
  %51 = load i32* %edge, align 4
  %52 = load i32* @block_size, align 4
  %mul85 = mul nsw i32 %51, %52
  store i32 %mul85, i32* %size, align 4
  br label %if.end.88

if.else.86:                                       ; preds = %lor.lhs.false
  %53 = load i32* @block_size, align 4
  %54 = load i32* @block_size, align 4
  %mul87 = mul nsw i32 %53, %54
  store i32 %mul87, i32* %size, align 4
  br label %if.end.88

if.end.88:                                        ; preds = %if.else.86, %if.then.84
  br label %if.end.89

if.end.89:                                        ; preds = %if.end.88, %if.then.76
  %55 = load i32* %size, align 4
  %conv90 = sext i32 %55 to i64
  %mul91 = mul i64 %conv90, 8
  %56 = load i32* %proc_num, align 4
  %idxprom92 = sext i32 %56 to i64
  %57 = load i32** @proc_bytes, align 8
  %arrayidx93 = getelementptr inbounds i32* %57, i64 %idxprom92
  %58 = load i32* %arrayidx93, align 4
  %conv94 = sext i32 %58 to i64
  %add = add i64 %conv94, %mul91
  %conv95 = trunc i64 %add to i32
  store i32 %conv95, i32* %arrayidx93, align 4
  br label %for.inc.96

for.inc.96:                                       ; preds = %if.end.89
  %59 = load i32* %j, align 4
  %inc97 = add nsw i32 %59, 1
  store i32 %inc97, i32* %j, align 4
  br label %for.cond.66

for.end.98:                                       ; preds = %for.cond.66
  br label %for.inc.99

for.inc.99:                                       ; preds = %for.end.98
  %60 = load i32* %i, align 4
  %inc100 = add nsw i32 %60, 1
  store i32 %inc100, i32* %i, align 4
  br label %for.cond.62

for.end.101:                                      ; preds = %for.cond.62
  store i32 0, i32* %i, align 4
  br label %for.cond.102

for.cond.102:                                     ; preds = %for.inc.130, %for.end.101
  %61 = load i32* %i, align 4
  %62 = load i32* @P, align 4
  %cmp103 = icmp slt i32 %61, %62
  br i1 %cmp103, label %for.body.105, label %for.end.132

for.body.105:                                     ; preds = %for.cond.102
  %63 = load i32* %i, align 4
  %idxprom106 = sext i32 %63 to i64
  %64 = load i32** @proc_bytes, align 8
  %arrayidx107 = getelementptr inbounds i32* %64, i64 %idxprom106
  %65 = load i32* %arrayidx107, align 4
  %add108 = add nsw i32 %65, 4096
  %conv109 = sext i32 %add108 to i64
  %call110 = call noalias i8* @malloc(i64 %conv109)
  %66 = bitcast i8* %call110 to double*
  %67 = load i32* %i, align 4
  %idxprom111 = sext i32 %67 to i64
  %68 = load double*** @last_malloc, align 8
  %arrayidx112 = getelementptr inbounds double** %68, i64 %idxprom111
  store double* %66, double** %arrayidx112, align 8
  %69 = load i32* %i, align 4
  %idxprom113 = sext i32 %69 to i64
  %70 = load double*** @last_malloc, align 8
  %arrayidx114 = getelementptr inbounds double** %70, i64 %idxprom113
  %71 = load double** %arrayidx114, align 8
  %cmp115 = icmp eq double* %71, null
  br i1 %cmp115, label %if.then.117, label %if.end.119

if.then.117:                                      ; preds = %for.body.105
  br label %UnifiedUnreachableBlock

if.end.119:                                       ; preds = %for.body.105
  %72 = load i32* %i, align 4
  %idxprom120 = sext i32 %72 to i64
  %73 = load double*** @last_malloc, align 8
  %arrayidx121 = getelementptr inbounds double** %73, i64 %idxprom120
  %74 = load double** %arrayidx121, align 8
  %75 = ptrtoint double* %74 to i32
  %add122 = add i32 %75, 4096
  %76 = load i32* %i, align 4
  %idxprom123 = sext i32 %76 to i64
  %77 = load double*** @last_malloc, align 8
  %arrayidx124 = getelementptr inbounds double** %77, i64 %idxprom123
  %78 = load double** %arrayidx124, align 8
  %79 = ptrtoint double* %78 to i32
  %rem125 = urem i32 %79, 4096
  %sub126 = sub i32 %add122, %rem125
  %conv127 = zext i32 %sub126 to i64
  %80 = inttoptr i64 %conv127 to double*
  %81 = load i32* %i, align 4
  %idxprom128 = sext i32 %81 to i64
  %82 = load double*** @last_malloc, align 8
  %arrayidx129 = getelementptr inbounds double** %82, i64 %idxprom128
  store double* %80, double** %arrayidx129, align 8
  br label %for.inc.130

for.inc.130:                                      ; preds = %if.end.119
  %83 = load i32* %i, align 4
  %inc131 = add nsw i32 %83, 1
  store i32 %inc131, i32* %i, align 4
  br label %for.cond.102

for.end.132:                                      ; preds = %for.cond.102
  %84 = load i32* @nblocks, align 4
  %85 = load i32* @nblocks, align 4
  %mul133 = mul nsw i32 %84, %85
  %conv134 = sext i32 %mul133 to i64
  %mul135 = mul i64 %conv134, 8
  %call136 = call noalias i8* @malloc(i64 %mul135)
  %86 = bitcast i8* %call136 to double**
  store double** %86, double*** @a, align 8
  %87 = load double*** @a, align 8
  %cmp137 = icmp eq double** %87, null
  br i1 %cmp137, label %if.then.139, label %if.end.140

if.then.139:                                      ; preds = %for.end.132
  br label %UnifiedUnreachableBlock

if.end.140:                                       ; preds = %for.end.132
  store i32 0, i32* %i, align 4
  br label %for.cond.141

for.cond.141:                                     ; preds = %for.inc.184, %if.end.140
  %88 = load i32* %i, align 4
  %89 = load i32* @nblocks, align 4
  %cmp142 = icmp slt i32 %88, %89
  br i1 %cmp142, label %for.body.144, label %for.end.186

for.body.144:                                     ; preds = %for.cond.141
  store i32 0, i32* %j, align 4
  br label %for.cond.145

for.cond.145:                                     ; preds = %for.inc.181, %for.body.144
  %90 = load i32* %j, align 4
  %91 = load i32* @nblocks, align 4
  %cmp146 = icmp slt i32 %90, %91
  br i1 %cmp146, label %for.body.148, label %for.end.183

for.body.148:                                     ; preds = %for.cond.145
  %92 = load i32* %i, align 4
  %93 = load i32* %j, align 4
  %call149 = call i32 @BlockOwner(i32 %92, i32 %93)
  store i32 %call149, i32* %proc_num, align 4
  %94 = load i32* %proc_num, align 4
  %idxprom150 = sext i32 %94 to i64
  %95 = load double*** @last_malloc, align 8
  %arrayidx151 = getelementptr inbounds double** %95, i64 %idxprom150
  %96 = load double** %arrayidx151, align 8
  %97 = load i32* %i, align 4
  %98 = load i32* %j, align 4
  %99 = load i32* @nblocks, align 4
  %mul152 = mul nsw i32 %98, %99
  %add153 = add nsw i32 %97, %mul152
  %idxprom154 = sext i32 %add153 to i64
  %100 = load double*** @a, align 8
  %arrayidx155 = getelementptr inbounds double** %100, i64 %idxprom154
  store double* %96, double** %arrayidx155, align 8
  %101 = load i32* %i, align 4
  %102 = load i32* @nblocks, align 4
  %sub156 = sub nsw i32 %102, 1
  %cmp157 = icmp eq i32 %101, %sub156
  br i1 %cmp157, label %land.lhs.true.159, label %if.else.165

land.lhs.true.159:                                ; preds = %for.body.148
  %103 = load i32* %j, align 4
  %104 = load i32* @nblocks, align 4
  %sub160 = sub nsw i32 %104, 1
  %cmp161 = icmp eq i32 %103, %sub160
  br i1 %cmp161, label %if.then.163, label %if.else.165

if.then.163:                                      ; preds = %land.lhs.true.159
  %105 = load i32* %edge, align 4
  %106 = load i32* %edge, align 4
  %mul164 = mul nsw i32 %105, %106
  store i32 %mul164, i32* %size, align 4
  br label %if.end.178

if.else.165:                                      ; preds = %land.lhs.true.159, %for.body.148
  %107 = load i32* %i, align 4
  %108 = load i32* @nblocks, align 4
  %sub166 = sub nsw i32 %108, 1
  %cmp167 = icmp eq i32 %107, %sub166
  br i1 %cmp167, label %if.then.173, label %lor.lhs.false.169

lor.lhs.false.169:                                ; preds = %if.else.165
  %109 = load i32* %j, align 4
  %110 = load i32* @nblocks, align 4
  %sub170 = sub nsw i32 %110, 1
  %cmp171 = icmp eq i32 %109, %sub170
  br i1 %cmp171, label %if.then.173, label %if.else.175

if.then.173:                                      ; preds = %lor.lhs.false.169, %if.else.165
  %111 = load i32* %edge, align 4
  %112 = load i32* @block_size, align 4
  %mul174 = mul nsw i32 %111, %112
  store i32 %mul174, i32* %size, align 4
  br label %if.end.177

if.else.175:                                      ; preds = %lor.lhs.false.169
  %113 = load i32* @block_size, align 4
  %114 = load i32* @block_size, align 4
  %mul176 = mul nsw i32 %113, %114
  store i32 %mul176, i32* %size, align 4
  br label %if.end.177

if.end.177:                                       ; preds = %if.else.175, %if.then.173
  br label %if.end.178

if.end.178:                                       ; preds = %if.end.177, %if.then.163
  %115 = load i32* %size, align 4
  %116 = load i32* %proc_num, align 4
  %idxprom179 = sext i32 %116 to i64
  %117 = load double*** @last_malloc, align 8
  %arrayidx180 = getelementptr inbounds double** %117, i64 %idxprom179
  %118 = load double** %arrayidx180, align 8
  %idx.ext = sext i32 %115 to i64
  %add.ptr = getelementptr inbounds double* %118, i64 %idx.ext
  store double* %add.ptr, double** %arrayidx180, align 8
  br label %for.inc.181

for.inc.181:                                      ; preds = %if.end.178
  %119 = load i32* %j, align 4
  %inc182 = add nsw i32 %119, 1
  store i32 %inc182, i32* %j, align 4
  br label %for.cond.145

for.end.183:                                      ; preds = %for.cond.145
  br label %for.inc.184

for.inc.184:                                      ; preds = %for.end.183
  %120 = load i32* %i, align 4
  %inc185 = add nsw i32 %120, 1
  store i32 %inc185, i32* %i, align 4
  br label %for.cond.141

for.end.186:                                      ; preds = %for.cond.141
  %121 = load i32* @n, align 4
  %conv187 = sext i32 %121 to i64
  %mul188 = mul i64 %conv187, 8
  %call189 = call noalias i8* @malloc(i64 %mul188)
  %122 = bitcast i8* %call189 to double*
  store double* %122, double** @rhs, align 8
  %123 = load double** @rhs, align 8
  %cmp190 = icmp eq double* %123, null
  br i1 %cmp190, label %if.then.192, label %if.end.193

if.then.192:                                      ; preds = %for.end.186
  br label %UnifiedUnreachableBlock

if.end.193:                                       ; preds = %for.end.186
  %call194 = call noalias i8* @malloc(i64 120)
  %124 = bitcast i8* %call194 to %struct.GlobalMemory*
  store %struct.GlobalMemory* %124, %struct.GlobalMemory** @Global, align 8
  %125 = load i32* @P, align 4
  %conv195 = sext i32 %125 to i64
  %mul196 = mul i64 %conv195, 8
  %call197 = call noalias i8* @malloc(i64 %mul196)
  %126 = bitcast i8* %call197 to double*
  %127 = load %struct.GlobalMemory** @Global, align 8
  %t_in_fac = getelementptr inbounds %struct.GlobalMemory* %127, i32 0, i32 0
  store double* %126, double** %t_in_fac, align 8
  %128 = load i32* @P, align 4
  %conv198 = sext i32 %128 to i64
  %mul199 = mul i64 %conv198, 8
  %call200 = call noalias i8* @malloc(i64 %mul199)
  %129 = bitcast i8* %call200 to double*
  %130 = load %struct.GlobalMemory** @Global, align 8
  %t_in_mod = getelementptr inbounds %struct.GlobalMemory* %130, i32 0, i32 2
  store double* %129, double** %t_in_mod, align 8
  %131 = load i32* @P, align 4
  %conv201 = sext i32 %131 to i64
  %mul202 = mul i64 %conv201, 8
  %call203 = call noalias i8* @malloc(i64 %mul202)
  %132 = bitcast i8* %call203 to double*
  %133 = load %struct.GlobalMemory** @Global, align 8
  %t_in_solve = getelementptr inbounds %struct.GlobalMemory* %133, i32 0, i32 1
  store double* %132, double** %t_in_solve, align 8
  %134 = load i32* @P, align 4
  %conv204 = sext i32 %134 to i64
  %mul205 = mul i64 %conv204, 8
  %call206 = call noalias i8* @malloc(i64 %mul205)
  %135 = bitcast i8* %call206 to double*
  %136 = load %struct.GlobalMemory** @Global, align 8
  %t_in_bar = getelementptr inbounds %struct.GlobalMemory* %136, i32 0, i32 3
  store double* %135, double** %t_in_bar, align 8
  %137 = load i32* @P, align 4
  %conv207 = sext i32 %137 to i64
  %mul208 = mul i64 %conv207, 8
  %call209 = call noalias i8* @malloc(i64 %mul208)
  %138 = bitcast i8* %call209 to double*
  %139 = load %struct.GlobalMemory** @Global, align 8
  %completion = getelementptr inbounds %struct.GlobalMemory* %139, i32 0, i32 4
  store double* %138, double** %completion, align 8
  %140 = load %struct.GlobalMemory** @Global, align 8
  %cmp210 = icmp eq %struct.GlobalMemory* %140, null
  br i1 %cmp210, label %if.then.212, label %if.else.213

if.then.212:                                      ; preds = %if.end.193
  br label %UnifiedUnreachableBlock

if.else.213:                                      ; preds = %if.end.193
  %141 = load %struct.GlobalMemory** @Global, align 8
  %t_in_fac214 = getelementptr inbounds %struct.GlobalMemory* %141, i32 0, i32 0
  %142 = load double** %t_in_fac214, align 8
  %cmp215 = icmp eq double* %142, null
  br i1 %cmp215, label %if.then.217, label %if.else.218

if.then.217:                                      ; preds = %if.else.213
  br label %UnifiedUnreachableBlock

if.else.218:                                      ; preds = %if.else.213
  %143 = load %struct.GlobalMemory** @Global, align 8
  %t_in_mod219 = getelementptr inbounds %struct.GlobalMemory* %143, i32 0, i32 2
  %144 = load double** %t_in_mod219, align 8
  %cmp220 = icmp eq double* %144, null
  br i1 %cmp220, label %if.then.222, label %if.else.223

if.then.222:                                      ; preds = %if.else.218
  br label %UnifiedUnreachableBlock

if.else.223:                                      ; preds = %if.else.218
  %145 = load %struct.GlobalMemory** @Global, align 8
  %t_in_solve224 = getelementptr inbounds %struct.GlobalMemory* %145, i32 0, i32 1
  %146 = load double** %t_in_solve224, align 8
  %cmp225 = icmp eq double* %146, null
  br i1 %cmp225, label %if.then.227, label %if.else.228

if.then.227:                                      ; preds = %if.else.223
  br label %UnifiedUnreachableBlock

if.else.228:                                      ; preds = %if.else.223
  %147 = load %struct.GlobalMemory** @Global, align 8
  %t_in_bar229 = getelementptr inbounds %struct.GlobalMemory* %147, i32 0, i32 3
  %148 = load double** %t_in_bar229, align 8
  %cmp230 = icmp eq double* %148, null
  br i1 %cmp230, label %if.then.232, label %if.else.233

if.then.232:                                      ; preds = %if.else.228
  br label %UnifiedUnreachableBlock

if.else.233:                                      ; preds = %if.else.228
  %149 = load %struct.GlobalMemory** @Global, align 8
  %completion234 = getelementptr inbounds %struct.GlobalMemory* %149, i32 0, i32 4
  %150 = load double** %completion234, align 8
  %cmp235 = icmp eq double* %150, null
  br i1 %cmp235, label %if.then.237, label %if.end.238

if.then.237:                                      ; preds = %if.else.233
  br label %UnifiedUnreachableBlock

if.end.238:                                       ; preds = %if.else.233
  br label %if.end.239

if.end.239:                                       ; preds = %if.end.238
  br label %if.end.240

if.end.240:                                       ; preds = %if.end.239
  br label %if.end.241

if.end.241:                                       ; preds = %if.end.240
  br label %if.end.242

if.end.242:                                       ; preds = %if.end.241
  br label %if.end.243

if.end.243:                                       ; preds = %if.end.242
  store i32 2, i32* @P
  %151 = load %struct.GlobalMemory** @Global, align 8
  %start244 = getelementptr inbounds %struct.GlobalMemory* %151, i32 0, i32 10
  %gsense = getelementptr inbounds %struct.barrier_t* %start244, i32 0, i32 0
  store volatile i32 1, i32* %gsense, align 4
  %152 = load %struct.GlobalMemory** @Global, align 8
  %start245 = getelementptr inbounds %struct.GlobalMemory* %152, i32 0, i32 10
  %count = getelementptr inbounds %struct.barrier_t* %start245, i32 0, i32 1
  store volatile i64 0, i64* %count, align 8
  %153 = load %struct.GlobalMemory** @Global, align 8
  %id = getelementptr inbounds %struct.GlobalMemory* %153, i32 0, i32 9
  store i32 0, i32* %id, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond.247

for.cond.247:                                     ; preds = %for.inc.252, %if.end.243
  %154 = load i32* %i, align 4
  %155 = load i32* @P, align 4
  %cmp248 = icmp slt i32 %154, %155
  br i1 %cmp248, label %for.body.250, label %for.end.254

for.body.250:                                     ; preds = %for.cond.247
  %call251 = call i32 @pthread_create(i64* %t, %union.pthread_attr_t* null, i8* (i8*)* bitcast (void ()* @SlaveStart to i8* (i8*)*), i8* null)
  br label %for.inc.252

for.inc.252:                                      ; preds = %for.body.250
  %156 = load i32* %i, align 4
  %inc253 = add nsw i32 %156, 1
  store i32 %inc253, i32* %i, align 4
  br label %for.cond.247

for.end.254:                                      ; preds = %for.cond.247
  %157 = load double** @rhs, align 8
  call void @InitA(double* %157)
  br label %if.end.258

if.then.256:                                      ; No predecessors!
  br label %if.end.258

if.end.258:                                       ; preds = %for.end.254, %if.then.256
  call void @SlaveStart()
  %158 = load i32* @doprint, align 4
  %tobool259 = icmp ne i32 %158, 0
  br i1 %tobool259, label %if.then.260, label %if.end.262

if.then.260:                                      ; preds = %if.end.258
  call void @PrintA()
  br label %if.end.262

if.end.262:                                       ; preds = %if.then.260, %if.end.258
  br label %if.end.419

if.then.264:                                      ; No predecessors!
  br label %for.cond.267

for.cond.267:                                     ; preds = %for.inc.295, %if.then.264
  br label %for.end.297

for.body.270:                                     ; No predecessors!
  br label %if.end.280

if.then.276:                                      ; No predecessors!
  br label %if.end.280

if.end.280:                                       ; preds = %for.body.270, %if.then.276
  br label %if.end.290

if.then.286:                                      ; No predecessors!
  br label %if.end.290

if.end.290:                                       ; preds = %if.end.280, %if.then.286
  br label %for.inc.295

for.inc.295:                                      ; preds = %if.end.290
  br label %for.cond.267

for.end.297:                                      ; preds = %for.cond.267
  br label %for.cond.308

for.cond.308:                                     ; preds = %for.inc.408, %for.end.297
  br label %for.end.410

for.body.311:                                     ; No predecessors!
  br label %if.end.321

if.then.317:                                      ; No predecessors!
  br label %if.end.321

if.end.321:                                       ; preds = %for.body.311, %if.then.317
  br label %if.end.331

if.then.327:                                      ; No predecessors!
  br label %if.end.331

if.end.331:                                       ; preds = %if.end.321, %if.then.327
  br label %if.end.341

if.then.337:                                      ; No predecessors!
  br label %if.end.341

if.end.341:                                       ; preds = %if.end.331, %if.then.337
  br label %if.end.351

if.then.347:                                      ; No predecessors!
  br label %if.end.351

if.end.351:                                       ; preds = %if.end.341, %if.then.347
  br label %if.end.361

if.then.357:                                      ; No predecessors!
  br label %if.end.361

if.end.361:                                       ; preds = %if.end.351, %if.then.357
  br label %if.end.371

if.then.367:                                      ; No predecessors!
  br label %if.end.371

if.end.371:                                       ; preds = %if.end.361, %if.then.367
  br label %if.end.381

if.then.377:                                      ; No predecessors!
  br label %if.end.381

if.end.381:                                       ; preds = %if.end.371, %if.then.377
  br label %if.end.391

if.then.387:                                      ; No predecessors!
  br label %if.end.391

if.end.391:                                       ; preds = %if.end.381, %if.then.387
  br label %for.inc.408

for.inc.408:                                      ; preds = %if.end.391
  br label %for.cond.308

for.end.410:                                      ; preds = %for.cond.308
  br label %if.end.419

if.end.419:                                       ; preds = %if.end.262, %for.end.410
  br label %if.end.462

if.then.435:                                      ; No predecessors!
  br label %for.cond.436

for.cond.436:                                     ; preds = %for.inc.456, %if.then.435
  br label %for.end.458

for.body.439:                                     ; No predecessors!
  br label %for.inc.456

for.inc.456:                                      ; preds = %for.body.439
  br label %for.cond.436

for.end.458:                                      ; preds = %for.cond.436
  br label %if.end.462

if.end.462:                                       ; preds = %if.end.419, %for.end.458
  br label %if.end.481

if.then.479:                                      ; No predecessors!
  br label %if.end.481

if.end.481:                                       ; preds = %if.end.462, %if.then.479
  br label %UnifiedUnreachableBlock

return:                                           ; No predecessors!
  ret i32 undef

UnifiedUnreachableBlock:                          ; preds = %if.end.481, %if.then.237, %if.then.232, %if.then.227, %if.then.222, %if.then.217, %if.then.212, %if.then.192, %if.then.139, %if.then.117, %sw.bb.14
  call void @waitForAll()
  unreachable
}

; Function Attrs: nounwind
declare i64 @time(i64*)

declare i32 @getopt(...)

; Function Attrs: nounwind readonly
declare i32 @atoi(i8*)

declare i32 @printf(i8*, ...)

; Function Attrs: noreturn nounwind
declare void @exit(i32)

; Function Attrs: nounwind
declare double @sqrt(double)

; Function Attrs: nounwind
declare noalias i8* @malloc(i64)

; Function Attrs: nounwind uwtable
define internal i32 @BlockOwner(i32 %I, i32 %J) {
entry:
  %I.addr = alloca i32, align 4
  %J.addr = alloca i32, align 4
  store i32 %I, i32* %I.addr, align 4
  store i32 %J, i32* %J.addr, align 4
  %0 = load i32* %J.addr, align 4
  %1 = load i32* @num_cols, align 4
  %rem = srem i32 %0, %1
  %2 = load i32* %I.addr, align 4
  %3 = load i32* @num_rows, align 4
  %rem1 = srem i32 %2, %3
  %4 = load i32* @num_cols, align 4
  %mul = mul nsw i32 %rem1, %4
  %add = add nsw i32 %rem, %mul
  ret i32 %add
}

declare i32 @fprintf(%struct._IO_FILE*, i8*, ...)

; Function Attrs: nounwind uwtable
define internal void @printerr(i8* %s) {
entry:
  %s.addr = alloca i8*, align 8
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_init(%union.pthread_mutex_t*, %union.pthread_mutexattr_t*)

; Function Attrs: nounwind
declare i32 @pthread_create(i64*, %union.pthread_attr_t*, i8* (i8*)*, i8*)

; Function Attrs: nounwind uwtable
define internal void @InitA(double* %rhs) {
entry:
  %rhs.addr = alloca double*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %ii = alloca i32, align 4
  %jj = alloca i32, align 4
  %edge = alloca i32, align 4
  %ibs = alloca i32, align 4
  %jbs = alloca i32, align 4
  %skip = alloca i32, align 4
  %0 = load i32* @n, align 4
  %1 = load i32* @block_size, align 4
  %rem = srem i32 %0, %1
  store i32 %rem, i32* %edge, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.29, %entry
  %2 = load i32* %j, align 4
  %3 = load i32* @n, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end.31

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond.1

for.cond.1:                                       ; preds = %for.inc, %for.body
  %4 = load i32* %i, align 4
  %5 = load i32* @n, align 4
  %cmp2 = icmp slt i32 %4, %5
  br i1 %cmp2, label %for.body.3, label %for.end

for.body.3:                                       ; preds = %for.cond.1
  %6 = load i32* @n, align 4
  %7 = load i32* %i, align 4
  %sub = sub nsw i32 %6, %7
  %8 = load i32* %edge, align 4
  %cmp4 = icmp sle i32 %sub, %8
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %for.body.3
  %9 = load i32* @n, align 4
  %10 = load i32* %edge, align 4
  %sub5 = sub nsw i32 %9, %10
  store i32 %sub5, i32* %ibs, align 4
  %11 = load i32* %edge, align 4
  store i32 %11, i32* %skip, align 4
  br label %if.end

if.else:                                          ; preds = %for.body.3
  %12 = load i32* @block_size, align 4
  store i32 %12, i32* %ibs, align 4
  %13 = load i32* @block_size, align 4
  store i32 %13, i32* %skip, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %14 = load i32* @n, align 4
  %15 = load i32* %j, align 4
  %sub6 = sub nsw i32 %14, %15
  %16 = load i32* %edge, align 4
  %cmp7 = icmp sle i32 %sub6, %16
  br i1 %cmp7, label %if.then.8, label %if.else.10

if.then.8:                                        ; preds = %if.end
  %17 = load i32* @n, align 4
  %18 = load i32* %edge, align 4
  %sub9 = sub nsw i32 %17, %18
  store i32 %sub9, i32* %jbs, align 4
  br label %if.end.11

if.else.10:                                       ; preds = %if.end
  %19 = load i32* @block_size, align 4
  store i32 %19, i32* %jbs, align 4
  br label %if.end.11

if.end.11:                                        ; preds = %if.else.10, %if.then.8
  %20 = load i32* %i, align 4
  %21 = load i32* @block_size, align 4
  %div = sdiv i32 %20, %21
  %22 = load i32* %j, align 4
  %23 = load i32* @block_size, align 4
  %div12 = sdiv i32 %22, %23
  %24 = load i32* @nblocks, align 4
  %mul = mul nsw i32 %div12, %24
  %add = add nsw i32 %div, %mul
  store i32 %add, i32* %ii, align 4
  %25 = load i32* %i, align 4
  %26 = load i32* %ibs, align 4
  %rem13 = srem i32 %25, %26
  %27 = load i32* %j, align 4
  %28 = load i32* %jbs, align 4
  %rem14 = srem i32 %27, %28
  %29 = load i32* %skip, align 4
  %mul15 = mul nsw i32 %rem14, %29
  %add16 = add nsw i32 %rem13, %mul15
  store i32 %add16, i32* %jj, align 4
  %call = call i64 @lrand48()
  %conv = sitofp i64 %call to double
  %div17 = fdiv double %conv, 3.276700e+04
  %30 = load i32* %jj, align 4
  %idxprom = sext i32 %30 to i64
  %31 = load i32* %ii, align 4
  %idxprom18 = sext i32 %31 to i64
  %32 = load double*** @a, align 8
  %arrayidx = getelementptr inbounds double** %32, i64 %idxprom18
  %33 = load double** %arrayidx, align 8
  %arrayidx19 = getelementptr inbounds double* %33, i64 %idxprom
  store double %div17, double* %arrayidx19, align 8
  %34 = load i32* %i, align 4
  %35 = load i32* %j, align 4
  %cmp20 = icmp eq i32 %34, %35
  br i1 %cmp20, label %if.then.22, label %if.end.28

if.then.22:                                       ; preds = %if.end.11
  %36 = load i32* %jj, align 4
  %idxprom23 = sext i32 %36 to i64
  %37 = load i32* %ii, align 4
  %idxprom24 = sext i32 %37 to i64
  %38 = load double*** @a, align 8
  %arrayidx25 = getelementptr inbounds double** %38, i64 %idxprom24
  %39 = load double** %arrayidx25, align 8
  %arrayidx26 = getelementptr inbounds double* %39, i64 %idxprom23
  %40 = load double* %arrayidx26, align 8
  %mul27 = fmul double %40, 1.000000e+01
  store double %mul27, double* %arrayidx26, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.22, %if.end.11
  br label %for.inc

for.inc:                                          ; preds = %if.end.28
  %41 = load i32* %i, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond.1

for.end:                                          ; preds = %for.cond.1
  br label %for.inc.29

for.inc.29:                                       ; preds = %for.end
  %42 = load i32* %j, align 4
  %inc30 = add nsw i32 %42, 1
  store i32 %inc30, i32* %j, align 4
  br label %for.cond

for.end.31:                                       ; preds = %for.cond
  br label %for.cond.32

for.cond.32:                                      ; preds = %for.inc.38, %for.end.31
  br label %for.end.40

for.body.35:                                      ; No predecessors!
  br label %for.inc.38

for.inc.38:                                       ; preds = %for.body.35
  br label %for.cond.32

for.end.40:                                       ; preds = %for.cond.32
  br label %for.cond.41

for.cond.41:                                      ; preds = %for.inc.81, %for.end.40
  br label %for.end.83

for.body.44:                                      ; No predecessors!
  br label %for.cond.45

for.cond.45:                                      ; preds = %for.inc.78, %for.body.44
  br label %for.end.80

for.body.48:                                      ; No predecessors!
  br label %if.end.55

if.then.52:                                       ; No predecessors!
  br label %if.end.55

if.else.54:                                       ; No predecessors!
  br label %if.end.55

if.end.55:                                        ; preds = %for.body.48, %if.else.54, %if.then.52
  br label %if.end.62

if.then.59:                                       ; No predecessors!
  br label %if.end.62

if.else.61:                                       ; No predecessors!
  br label %if.end.62

if.end.62:                                        ; preds = %if.end.55, %if.else.61, %if.then.59
  br label %for.inc.78

for.inc.78:                                       ; preds = %if.end.62
  br label %for.cond.45

for.end.80:                                       ; preds = %for.cond.45
  br label %for.inc.81

for.inc.81:                                       ; preds = %for.end.80
  br label %for.cond.41

for.end.83:                                       ; preds = %for.cond.41
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @CheckResult(i32 %n, double** %a, double* %rhs) {
entry:
  %n.addr = alloca i32, align 4
  %a.addr = alloca double**, align 8
  %rhs.addr = alloca double*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %bogus = alloca i32, align 4
  %y = alloca double*, align 8
  %diff = alloca double, align 8
  %max_diff = alloca double, align 8
  %ii = alloca i32, align 4
  %jj = alloca i32, align 4
  %edge = alloca i32, align 4
  %ibs = alloca i32, align 4
  %jbs = alloca i32, align 4
  %skip = alloca i32, align 4
  br i1 undef, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  unreachable

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  br label %for.end

for.body:                                         ; No predecessors!
  br label %for.inc

for.inc:                                          ; preds = %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond.6

for.cond.6:                                       ; preds = %for.inc.63, %for.end
  br label %for.end.65

for.body.9:                                       ; No predecessors!
  br label %if.end.14

if.then.12:                                       ; No predecessors!
  br label %if.end.14

if.else:                                          ; No predecessors!
  br label %if.end.14

if.end.14:                                        ; preds = %for.body.9, %if.else, %if.then.12
  br label %for.cond.31

for.cond.31:                                      ; preds = %for.inc.60, %if.end.14
  br label %for.end.62

for.body.34:                                      ; No predecessors!
  br label %if.end.41

if.then.38:                                       ; No predecessors!
  br label %if.end.41

if.else.40:                                       ; No predecessors!
  br label %if.end.41

if.end.41:                                        ; preds = %for.body.34, %if.else.40, %if.then.38
  br label %for.inc.60

for.inc.60:                                       ; preds = %if.end.41
  br label %for.cond.31

for.end.62:                                       ; preds = %for.cond.31
  br label %for.inc.63

for.inc.63:                                       ; preds = %for.end.62
  br label %for.cond.6

for.end.65:                                       ; preds = %for.cond.6
  br label %for.cond.67

for.cond.67:                                      ; preds = %for.inc.110, %for.end.65
  br label %for.end.111

for.body.70:                                      ; No predecessors!
  br label %for.cond.71

for.cond.71:                                      ; preds = %for.inc.107, %for.body.70
  br label %for.end.109

for.body.74:                                      ; No predecessors!
  br label %if.end.81

if.then.78:                                       ; No predecessors!
  br label %if.end.81

if.else.80:                                       ; No predecessors!
  br label %if.end.81

if.end.81:                                        ; preds = %for.body.74, %if.else.80, %if.then.78
  br label %if.end.88

if.then.85:                                       ; No predecessors!
  br label %if.end.88

if.else.87:                                       ; No predecessors!
  br label %if.end.88

if.end.88:                                        ; preds = %if.end.81, %if.else.87, %if.then.85
  br label %for.inc.107

for.inc.107:                                      ; preds = %if.end.88
  br label %for.cond.71

for.end.109:                                      ; preds = %for.cond.71
  br label %for.inc.110

for.inc.110:                                      ; preds = %for.end.109
  br label %for.cond.67

for.end.111:                                      ; preds = %for.cond.67
  br label %for.cond.112

for.cond.112:                                     ; preds = %for.inc.124, %for.end.111
  br label %for.end.126

for.body.115:                                     ; No predecessors!
  br label %if.end.123

if.then.122:                                      ; No predecessors!
  br label %if.end.123

if.end.123:                                       ; preds = %for.body.115, %if.then.122
  br label %for.inc.124

for.inc.124:                                      ; preds = %if.end.123
  br label %for.cond.112

for.end.126:                                      ; preds = %for.cond.112
  br label %if.end.131

if.then.127:                                      ; No predecessors!
  br label %if.end.131

if.else.129:                                      ; No predecessors!
  br label %if.end.131

if.end.131:                                       ; preds = %for.end.126, %if.else.129, %if.then.127
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @atomic_cmpxchg(i32 %oldcount, i32 %newcount) {
entry:
  %oldcount.addr = alloca i32, align 4
  %newcount.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  %updatedcount = alloca i32, align 4
  store i32 %oldcount, i32* %oldcount.addr, align 4
  store i32 %newcount, i32* %newcount.addr, align 4
  %0 = load %struct.GlobalMemory** @Global, align 8
  %start = getelementptr inbounds %struct.GlobalMemory* %0, i32 0, i32 10
  %count = getelementptr inbounds %struct.barrier_t* %start, i32 0, i32 1
  %1 = load volatile i64* %count, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, i32* %temp, align 4
  %2 = load i32* %oldcount.addr, align 4
  %3 = load i32* %temp, align 4
  %cmp = icmp eq i32 %2, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i32* %newcount.addr, align 4
  %conv2 = sext i32 %4 to i64
  %5 = load %struct.GlobalMemory** @Global, align 8
  %start3 = getelementptr inbounds %struct.GlobalMemory* %5, i32 0, i32 10
  %count4 = getelementptr inbounds %struct.barrier_t* %start3, i32 0, i32 1
  store volatile i64 %conv2, i64* %count4, align 8
  call void @snapshot64(i64 %conv2, i32 0)
  %6 = load i32* %oldcount.addr, align 4
  store i32 %6, i32* %updatedcount, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load %struct.GlobalMemory** @Global, align 8
  %start5 = getelementptr inbounds %struct.GlobalMemory* %7, i32 0, i32 10
  %count6 = getelementptr inbounds %struct.barrier_t* %start5, i32 0, i32 1
  %8 = load volatile i64* %count6, align 8
  %conv7 = trunc i64 %8 to i32
  store i32 %conv7, i32* %updatedcount, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %9 = load i32* %updatedcount, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal void @SlaveStart() {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %cluster = alloca i32, align 4
  %max_block = alloca i32, align 4
  %MyNum = alloca i32, align 4
  %0 = load %struct.GlobalMemory** @Global, align 8
  %id = getelementptr inbounds %struct.GlobalMemory* %0, i32 0, i32 9
  %1 = load i32* %id, align 4
  store i32 %1, i32* %MyNum, align 4
  %2 = load %struct.GlobalMemory** @Global, align 8
  %id1 = getelementptr inbounds %struct.GlobalMemory* %2, i32 0, i32 9
  %3 = load i32* %id1, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, i32* %id1, align 4
  %4 = load i32* @n, align 4
  %5 = load i32* @block_size, align 4
  %6 = load double*** @a, align 8
  %7 = load i32* %MyNum, align 4
  %8 = load i32* @dostats, align 4
  call void @OneSolve(i32 %4, i32 %5, double** %6, i32 %7, i32 %8)
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_lock(%union.pthread_mutex_t*)

; Function Attrs: nounwind
declare i32 @pthread_mutex_unlock(%union.pthread_mutex_t*)

; Function Attrs: nounwind uwtable
define internal void @OneSolve(i32 %n, i32 %block_size, double** %a, i32 %MyNum, i32 %dostats) {
entry:
  %n.addr = alloca i32, align 4
  %block_size.addr = alloca i32, align 4
  %a.addr = alloca double**, align 8
  %MyNum.addr = alloca i32, align 4
  %dostats.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %myrs = alloca i32, align 4
  %myrf = alloca i32, align 4
  %mydone = alloca i32, align 4
  %lc = alloca %struct.LocalCopies*, align 8
  %lsense = alloca i32, align 4
  %oldcount = alloca i32, align 4
  %newcount = alloca i32, align 4
  %updatedcount = alloca i32, align 4
  %retVal = alloca i32, align 4
  %lsense28 = alloca i32, align 4
  %oldcount33 = alloca i32, align 4
  %newcount37 = alloca i32, align 4
  %updatedcount39 = alloca i32, align 4
  %retVal40 = alloca i32, align 4
  %lsense85 = alloca i32, align 4
  %oldcount90 = alloca i32, align 4
  %newcount94 = alloca i32, align 4
  %updatedcount96 = alloca i32, align 4
  %retVal97 = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  store i32 %block_size, i32* %block_size.addr, align 4
  store i32 %MyNum, i32* %MyNum.addr, align 4
  store i32 %dostats, i32* %dostats.addr, align 4
  %call = call noalias i8* @malloc(i64 32)
  %0 = bitcast i8* %call to %struct.LocalCopies*
  store %struct.LocalCopies* %0, %struct.LocalCopies** %lc, align 8
  %1 = load %struct.LocalCopies** %lc, align 8
  %cmp = icmp eq %struct.LocalCopies* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  unreachable

if.end:                                           ; preds = %entry
  %2 = load %struct.GlobalMemory** @Global, align 8
  %start = getelementptr inbounds %struct.GlobalMemory* %2, i32 0, i32 10
  %gsense = getelementptr inbounds %struct.barrier_t* %start, i32 0, i32 0
  call void @printChar(i8 signext 49)
  call void @printChar(i8 signext 90)
  call void @InitializeSwitchesAndCounter()
  call void @IncrementCounter()
  %3 = load volatile i32* %gsense, align 4
  store i32 %3, i32* %lsense, align 4
  br label %while.body

while.body:                                       ; preds = %if.end.20, %if.end
  %4 = load %struct.GlobalMemory** @Global, align 8
  %start2 = getelementptr inbounds %struct.GlobalMemory* %4, i32 0, i32 10
  %count = getelementptr inbounds %struct.barrier_t* %start2, i32 0, i32 1
  %5 = load volatile i64* %count, align 8
  %call1 = call i32 @sleep(i32 1)
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %oldcount, align 4
  %6 = load i32* %oldcount, align 4
  %7 = load i32* %lsense, align 4
  %add = add nsw i32 %6, %7
  store i32 %add, i32* %newcount, align 4
  %8 = load i32* %oldcount, align 4
  %9 = load i32* %newcount, align 4
  %call3 = call i32 @atomic_cmpxchg(i32 %8, i32 %9)
  %call7 = call i32 @sleep(i32 1)
  store i32 %call3, i32* %updatedcount, align 4
  %10 = load i32* %updatedcount, align 4
  %11 = load i32* %oldcount, align 4
  %cmp4 = icmp eq i32 %10, %11
  br i1 %cmp4, label %if.then.6, label %if.end.20

if.then.6:                                        ; preds = %while.body
  %12 = load i32* %newcount, align 4
  %13 = load i32* @P, align 4
  %call2 = call i32 @sleep(i32 1)
  %cmp7 = icmp eq i32 %12, %13
  br i1 %cmp7, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.then.6
  %14 = load i32* %lsense, align 4
  %cmp9 = icmp eq i32 %14, 1
  br i1 %cmp9, label %if.then.16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.then.6
  %15 = load i32* %newcount, align 4
  %cmp11 = icmp eq i32 %15, 0
  br i1 %cmp11, label %land.lhs.true.13, label %if.end.19

land.lhs.true.13:                                 ; preds = %lor.lhs.false
  %16 = load i32* %lsense, align 4
  %cmp14 = icmp eq i32 %16, -1
  br i1 %cmp14, label %if.then.16, label %if.end.19

if.then.16:                                       ; preds = %land.lhs.true.13, %land.lhs.true
  %17 = load i32* %lsense, align 4
  %sub = sub nsw i32 0, %17
  %18 = load %struct.GlobalMemory** @Global, align 8
  %start17 = getelementptr inbounds %struct.GlobalMemory* %18, i32 0, i32 10
  %gsense18 = getelementptr inbounds %struct.barrier_t* %start17, i32 0, i32 0
  call void @printX()
  store volatile i32 %sub, i32* %gsense18, align 4
  call void @snapshot(i32 %sub, i32 1)
  %call4 = call i32 @sleep(i32 3)
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.16, %land.lhs.true.13, %lor.lhs.false
  br label %while.end

if.end.20:                                        ; preds = %while.body
  br label %while.body

while.end:                                        ; preds = %if.end.19
  br label %while.cond

while.cond:                                       ; preds = %while.body.25, %while.end
  %19 = load %struct.GlobalMemory** @Global, align 8
  %start21 = getelementptr inbounds %struct.GlobalMemory* %19, i32 0, i32 10
  %gsense22 = getelementptr inbounds %struct.barrier_t* %start21, i32 0, i32 0
  %20 = load volatile i32* %gsense22, align 4
  %21 = load i32* %lsense, align 4
  %cmp23 = icmp eq i32 %20, %21
  br i1 %cmp23, label %while.body.25, label %while.end.26

while.body.25:                                    ; preds = %while.cond
  %call5 = call i32 @sleep(i32 2)
  br label %while.cond

while.end.26:                                     ; preds = %while.cond
  call void @printY()
  %call6 = call i32 @sleep(i32 1)
  %22 = load i32* %block_size.addr, align 4
  %23 = load i32* %MyNum.addr, align 4
  %call27 = call double @TouchA(i32 %22, i32 %23)
  %24 = load %struct.GlobalMemory** @Global, align 8
  %start29 = getelementptr inbounds %struct.GlobalMemory* %24, i32 0, i32 10
  %gsense30 = getelementptr inbounds %struct.barrier_t* %start29, i32 0, i32 0
  call void @printChar(i8 signext 50)
  call void @printChar(i8 signext 90)
  call void @InitializeSwitchesAndCounter()
  call void @IncrementCounter()
  %25 = load volatile i32* %gsense30, align 4
  store i32 %25, i32* %lsense28, align 4
  br label %while.body.32

while.body.32:                                    ; preds = %if.end.61, %while.end.26
  %26 = load %struct.GlobalMemory** @Global, align 8
  %start34 = getelementptr inbounds %struct.GlobalMemory* %26, i32 0, i32 10
  %count35 = getelementptr inbounds %struct.barrier_t* %start34, i32 0, i32 1
  %27 = load volatile i64* %count35, align 8
  %call8 = call i32 @sleep(i32 1)
  %conv36 = trunc i64 %27 to i32
  store i32 %conv36, i32* %oldcount33, align 4
  %28 = load i32* %oldcount33, align 4
  %29 = load i32* %lsense28, align 4
  %add38 = add nsw i32 %28, %29
  store i32 %add38, i32* %newcount37, align 4
  %30 = load i32* %oldcount33, align 4
  %31 = load i32* %newcount37, align 4
  %call41 = call i32 @atomic_cmpxchg(i32 %30, i32 %31)
  %call13 = call i32 @sleep(i32 1)
  store i32 %call41, i32* %updatedcount39, align 4
  %32 = load i32* %updatedcount39, align 4
  %33 = load i32* %oldcount33, align 4
  %cmp42 = icmp eq i32 %32, %33
  br i1 %cmp42, label %if.then.44, label %if.end.61

if.then.44:                                       ; preds = %while.body.32
  %34 = load i32* %newcount37, align 4
  %35 = load i32* @P, align 4
  %call9 = call i32 @sleep(i32 1)
  %cmp45 = icmp eq i32 %34, %35
  br i1 %cmp45, label %land.lhs.true.47, label %lor.lhs.false.50

land.lhs.true.47:                                 ; preds = %if.then.44
  %36 = load i32* %lsense28, align 4
  %cmp48 = icmp eq i32 %36, 1
  br i1 %cmp48, label %if.then.56, label %lor.lhs.false.50

lor.lhs.false.50:                                 ; preds = %land.lhs.true.47, %if.then.44
  %37 = load i32* %newcount37, align 4
  %cmp51 = icmp eq i32 %37, 0
  br i1 %cmp51, label %land.lhs.true.53, label %if.end.60

land.lhs.true.53:                                 ; preds = %lor.lhs.false.50
  %38 = load i32* %lsense28, align 4
  %cmp54 = icmp eq i32 %38, -1
  br i1 %cmp54, label %if.then.56, label %if.end.60

if.then.56:                                       ; preds = %land.lhs.true.53, %land.lhs.true.47
  %39 = load i32* %lsense28, align 4
  %sub57 = sub nsw i32 0, %39
  %40 = load %struct.GlobalMemory** @Global, align 8
  %start58 = getelementptr inbounds %struct.GlobalMemory* %40, i32 0, i32 10
  %gsense59 = getelementptr inbounds %struct.barrier_t* %start58, i32 0, i32 0
  call void @printX()
  store volatile i32 %sub57, i32* %gsense59, align 4
  call void @snapshot(i32 %sub57, i32 1)
  %call10 = call i32 @sleep(i32 3)
  br label %if.end.60

if.end.60:                                        ; preds = %if.then.56, %land.lhs.true.53, %lor.lhs.false.50
  br label %while.end.62

if.end.61:                                        ; preds = %while.body.32
  br label %while.body.32

while.end.62:                                     ; preds = %if.end.60
  br label %while.cond.63

while.cond.63:                                    ; preds = %while.body.68, %while.end.62
  %41 = load %struct.GlobalMemory** @Global, align 8
  %start64 = getelementptr inbounds %struct.GlobalMemory* %41, i32 0, i32 10
  %gsense65 = getelementptr inbounds %struct.barrier_t* %start64, i32 0, i32 0
  %42 = load volatile i32* %gsense65, align 4
  %43 = load i32* %lsense28, align 4
  %cmp66 = icmp eq i32 %42, %43
  br i1 %cmp66, label %while.body.68, label %while.end.69

while.body.68:                                    ; preds = %while.cond.63
  %call11 = call i32 @sleep(i32 2)
  br label %while.cond.63

while.end.69:                                     ; preds = %while.cond.63
  call void @printY()
  %call12 = call i32 @sleep(i32 1)
  br label %if.end.76

lor.lhs.false.72:                                 ; No predecessors!
  br label %if.end.76

if.then.73:                                       ; No predecessors!
  br label %if.end.76

if.end.76:                                        ; preds = %lor.lhs.false.72, %while.end.69, %if.then.73
  %44 = load i32* %n.addr, align 4
  %45 = load i32* %block_size.addr, align 4
  %46 = load i32* %MyNum.addr, align 4
  %47 = load %struct.LocalCopies** %lc, align 8
  %48 = load i32* %dostats.addr, align 4
  call void @lu(i32 %44, i32 %45, i32 %46, %struct.LocalCopies* %47, i32 %48)
  br label %if.end.84

lor.lhs.false.79:                                 ; No predecessors!
  br label %if.end.84

if.then.81:                                       ; No predecessors!
  br label %if.end.84

if.end.84:                                        ; preds = %lor.lhs.false.79, %if.end.76, %if.then.81
  %49 = load %struct.GlobalMemory** @Global, align 8
  %start86 = getelementptr inbounds %struct.GlobalMemory* %49, i32 0, i32 10
  %gsense87 = getelementptr inbounds %struct.barrier_t* %start86, i32 0, i32 0
  call void @printChar(i8 signext 51)
  call void @printChar(i8 signext 90)
  call void @InitializeSwitchesAndCounter()
  call void @IncrementCounter()
  %50 = load volatile i32* %gsense87, align 4
  store i32 %50, i32* %lsense85, align 4
  br label %while.body.89

while.body.89:                                    ; preds = %if.end.118, %if.end.84
  %51 = load %struct.GlobalMemory** @Global, align 8
  %start91 = getelementptr inbounds %struct.GlobalMemory* %51, i32 0, i32 10
  %count92 = getelementptr inbounds %struct.barrier_t* %start91, i32 0, i32 1
  %52 = load volatile i64* %count92, align 8
  %call14 = call i32 @sleep(i32 1)
  %conv93 = trunc i64 %52 to i32
  store i32 %conv93, i32* %oldcount90, align 4
  %53 = load i32* %oldcount90, align 4
  %54 = load i32* %lsense85, align 4
  %add95 = add nsw i32 %53, %54
  store i32 %add95, i32* %newcount94, align 4
  %55 = load i32* %oldcount90, align 4
  %56 = load i32* %newcount94, align 4
  %call98 = call i32 @atomic_cmpxchg(i32 %55, i32 %56)
  %call19 = call i32 @sleep(i32 1)
  store i32 %call98, i32* %updatedcount96, align 4
  %57 = load i32* %updatedcount96, align 4
  %58 = load i32* %oldcount90, align 4
  %cmp99 = icmp eq i32 %57, %58
  br i1 %cmp99, label %if.then.101, label %if.end.118

if.then.101:                                      ; preds = %while.body.89
  %59 = load i32* %newcount94, align 4
  %60 = load i32* @P, align 4
  %call15 = call i32 @sleep(i32 1)
  %cmp102 = icmp eq i32 %59, %60
  br i1 %cmp102, label %land.lhs.true.104, label %lor.lhs.false.107

land.lhs.true.104:                                ; preds = %if.then.101
  %61 = load i32* %lsense85, align 4
  %cmp105 = icmp eq i32 %61, 1
  br i1 %cmp105, label %if.then.113, label %lor.lhs.false.107

lor.lhs.false.107:                                ; preds = %land.lhs.true.104, %if.then.101
  %62 = load i32* %newcount94, align 4
  %cmp108 = icmp eq i32 %62, 0
  br i1 %cmp108, label %land.lhs.true.110, label %if.end.117

land.lhs.true.110:                                ; preds = %lor.lhs.false.107
  %63 = load i32* %lsense85, align 4
  %cmp111 = icmp eq i32 %63, -1
  br i1 %cmp111, label %if.then.113, label %if.end.117

if.then.113:                                      ; preds = %land.lhs.true.110, %land.lhs.true.104
  %64 = load i32* %lsense85, align 4
  %sub114 = sub nsw i32 0, %64
  %65 = load %struct.GlobalMemory** @Global, align 8
  %start115 = getelementptr inbounds %struct.GlobalMemory* %65, i32 0, i32 10
  %gsense116 = getelementptr inbounds %struct.barrier_t* %start115, i32 0, i32 0
  call void @printX()
  store volatile i32 %sub114, i32* %gsense116, align 4
  call void @snapshot(i32 %sub114, i32 1)
  %call16 = call i32 @sleep(i32 3)
  br label %if.end.117

if.end.117:                                       ; preds = %if.then.113, %land.lhs.true.110, %lor.lhs.false.107
  br label %while.end.119

if.end.118:                                       ; preds = %while.body.89
  br label %while.body.89

while.end.119:                                    ; preds = %if.end.117
  br label %while.cond.120

while.cond.120:                                   ; preds = %while.body.125, %while.end.119
  %66 = load %struct.GlobalMemory** @Global, align 8
  %start121 = getelementptr inbounds %struct.GlobalMemory* %66, i32 0, i32 10
  %gsense122 = getelementptr inbounds %struct.barrier_t* %start121, i32 0, i32 0
  %67 = load volatile i32* %gsense122, align 4
  %68 = load i32* %lsense85, align 4
  %cmp123 = icmp eq i32 %67, %68
  br i1 %cmp123, label %while.body.125, label %while.end.126

while.body.125:                                   ; preds = %while.cond.120
  %call17 = call i32 @sleep(i32 2)
  br label %while.cond.120

while.end.126:                                    ; preds = %while.cond.120
  call void @printY()
  %call18 = call i32 @sleep(i32 1)
  br label %if.end.150

lor.lhs.false.129:                                ; No predecessors!
  br label %if.end.150

if.then.131:                                      ; No predecessors!
  br label %if.end.150

if.end.150:                                       ; preds = %lor.lhs.false.129, %while.end.126, %if.then.131
  br label %if.end.156

if.then.153:                                      ; No predecessors!
  br label %if.end.156

if.end.156:                                       ; preds = %if.end.150, %if.then.153
  ret void
}

declare void @Criteria(i32)

; Function Attrs: nounwind uwtable
define internal double @TouchA(i32 %bs, i32 %MyNum) {
entry:
  %bs.addr = alloca i32, align 4
  %MyNum.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %I = alloca i32, align 4
  %J = alloca i32, align 4
  %tot = alloca double, align 8
  %ibs = alloca i32, align 4
  %jbs = alloca i32, align 4
  store i32 0, i32* %J, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.37, %entry
  %0 = load i32* %J, align 4
  %1 = load i32* @nblocks, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end.39

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %I, align 4
  br label %for.cond.1

for.cond.1:                                       ; preds = %for.inc.34, %for.body
  %2 = load i32* %I, align 4
  %3 = load i32* @nblocks, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body.3, label %for.end.36

for.body.3:                                       ; preds = %for.cond.1
  %4 = load i32* %I, align 4
  %5 = load i32* %J, align 4
  %call = call i32 @BlockOwner(i32 %4, i32 %5)
  br label %if.end.33

if.then:                                          ; No predecessors!
  br label %if.end.9

if.then.6:                                        ; No predecessors!
  br label %if.end

if.then.8:                                        ; No predecessors!
  br label %if.end

if.end:                                           ; preds = %if.then.6, %if.then.8
  br label %if.end.9

if.else:                                          ; No predecessors!
  br label %if.end.9

if.end.9:                                         ; preds = %if.then, %if.else, %if.end
  br label %if.end.18

if.then.12:                                       ; No predecessors!
  br label %if.end.16

if.then.15:                                       ; No predecessors!
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.12, %if.then.15
  br label %if.end.18

if.else.17:                                       ; No predecessors!
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.9, %if.else.17, %if.end.16
  br label %for.cond.19

for.cond.19:                                      ; preds = %for.inc.30, %if.end.18
  br label %for.end.32

for.body.21:                                      ; No predecessors!
  br label %for.cond.22

for.cond.22:                                      ; preds = %for.inc, %for.body.21
  br label %for.end

for.body.24:                                      ; No predecessors!
  br label %for.inc

for.inc:                                          ; preds = %for.body.24
  br label %for.cond.22

for.end:                                          ; preds = %for.cond.22
  br label %for.inc.30

for.inc.30:                                       ; preds = %for.end
  br label %for.cond.19

for.end.32:                                       ; preds = %for.cond.19
  br label %if.end.33

if.end.33:                                        ; preds = %for.body.3, %for.end.32
  br label %for.inc.34

for.inc.34:                                       ; preds = %if.end.33
  %6 = load i32* %I, align 4
  %inc35 = add nsw i32 %6, 1
  store i32 %inc35, i32* %I, align 4
  br label %for.cond.1

for.end.36:                                       ; preds = %for.cond.1
  br label %for.inc.37

for.inc.37:                                       ; preds = %for.end.36
  %7 = load i32* %J, align 4
  %inc38 = add nsw i32 %7, 1
  store i32 %inc38, i32* %J, align 4
  br label %for.cond

for.end.39:                                       ; preds = %for.cond
  ret double undef
}

; Function Attrs: nounwind uwtable
define internal void @lu(i32 %n, i32 %bs, i32 %MyNum, %struct.LocalCopies* %lc, i32 %dostats) {
entry:
  %n.addr = alloca i32, align 4
  %bs.addr = alloca i32, align 4
  %MyNum.addr = alloca i32, align 4
  %lc.addr = alloca %struct.LocalCopies*, align 8
  %dostats.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %il = alloca i32, align 4
  %j = alloca i32, align 4
  %jl = alloca i32, align 4
  %k = alloca i32, align 4
  %kl = alloca i32, align 4
  %I = alloca i32, align 4
  %J = alloca i32, align 4
  %K = alloca i32, align 4
  %A = alloca double*, align 8
  %B = alloca double*, align 8
  %C = alloca double*, align 8
  %D = alloca double*, align 8
  %dimI = alloca i32, align 4
  %dimJ = alloca i32, align 4
  %dimK = alloca i32, align 4
  %strI = alloca i32, align 4
  %strJ = alloca i32, align 4
  %strK = alloca i32, align 4
  %t1 = alloca i32, align 4
  %t2 = alloca i32, align 4
  %t3 = alloca i32, align 4
  %t4 = alloca i32, align 4
  %t11 = alloca i32, align 4
  %t22 = alloca i32, align 4
  %diagowner = alloca i32, align 4
  %colowner = alloca i32, align 4
  %lsense = alloca i32, align 4
  %oldcount = alloca i32, align 4
  %newcount = alloca i32, align 4
  %updatedcount = alloca i32, align 4
  %retVal = alloca i32, align 4
  %lsense115 = alloca i32, align 4
  %oldcount120 = alloca i32, align 4
  %newcount124 = alloca i32, align 4
  %updatedcount126 = alloca i32, align 4
  %retVal127 = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  store i32 %bs, i32* %bs.addr, align 4
  store i32 %MyNum, i32* %MyNum.addr, align 4
  store i32 0, i32* %k, align 4
  store i32 0, i32* %K, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.237, %entry
  %0 = load i32* %k, align 4
  %1 = load i32* %n.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end.240

for.body:                                         ; preds = %for.cond
  %2 = load i32* %k, align 4
  %3 = load i32* %bs.addr, align 4
  %add = add nsw i32 %2, %3
  store i32 %add, i32* %kl, align 4
  %4 = load i32* %kl, align 4
  %5 = load i32* %n.addr, align 4
  %cmp1 = icmp sgt i32 %4, %5
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %6 = load i32* %n.addr, align 4
  store i32 %6, i32* %kl, align 4
  %7 = load i32* %kl, align 4
  %8 = load i32* %k, align 4
  %sub = sub nsw i32 %7, %8
  store i32 %sub, i32* %strK, align 4
  br label %if.end

if.else:                                          ; preds = %for.body
  %9 = load i32* %bs.addr, align 4
  store i32 %9, i32* %strK, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %if.end.4

lor.lhs.false:                                    ; No predecessors!
  br label %if.end.4

if.then.3:                                        ; No predecessors!
  br label %if.end.4

if.end.4:                                         ; preds = %lor.lhs.false, %if.end, %if.then.3
  %10 = load i32* %K, align 4
  %11 = load i32* %K, align 4
  %call5 = call i32 @BlockOwner(i32 %10, i32 %11)
  store i32 %call5, i32* %diagowner, align 4
  %12 = load i32* %diagowner, align 4
  %13 = load i32* %MyNum.addr, align 4
  %cmp6 = icmp eq i32 %12, %13
  br i1 %cmp6, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.4
  %14 = load i32* %K, align 4
  %15 = load i32* %K, align 4
  %16 = load i32* @nblocks, align 4
  %mul = mul nsw i32 %15, %16
  %add9 = add nsw i32 %14, %mul
  %idxprom = sext i32 %add9 to i64
  %17 = load double*** @a, align 8
  %arrayidx = getelementptr inbounds double** %17, i64 %idxprom
  %18 = load double** %arrayidx, align 8
  store double* %18, double** %A, align 8
  %19 = load double** %A, align 8
  %20 = load i32* %strK, align 4
  %21 = load i32* %strK, align 4
  call void @lu0(double* %19, i32 %20, i32 %21)
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.8, %if.end.4
  br label %if.end.18

lor.lhs.false.13:                                 ; No predecessors!
  br label %if.end.18

if.then.15:                                       ; No predecessors!
  br label %if.end.18

if.end.18:                                        ; preds = %lor.lhs.false.13, %if.end.10, %if.then.15
  %22 = load %struct.GlobalMemory** @Global, align 8
  %start = getelementptr inbounds %struct.GlobalMemory* %22, i32 0, i32 10
  %gsense = getelementptr inbounds %struct.barrier_t* %start, i32 0, i32 0
  call void @printChar(i8 signext 52)
  call void @printChar(i8 signext 90)
  call void @InitializeSwitchesAndCounter()
  call void @IncrementCounter()
  %23 = load volatile i32* %gsense, align 4
  store i32 %23, i32* %lsense, align 4
  br label %while.body

while.body:                                       ; preds = %if.end.41, %if.end.18
  %24 = load %struct.GlobalMemory** @Global, align 8
  %start19 = getelementptr inbounds %struct.GlobalMemory* %24, i32 0, i32 10
  %count = getelementptr inbounds %struct.barrier_t* %start19, i32 0, i32 1
  %25 = load volatile i64* %count, align 8
  %call = call i32 @sleep(i32 1)
  %conv20 = trunc i64 %25 to i32
  store i32 %conv20, i32* %oldcount, align 4
  %26 = load i32* %oldcount, align 4
  %27 = load i32* %lsense, align 4
  %add21 = add nsw i32 %26, %27
  store i32 %add21, i32* %newcount, align 4
  %28 = load i32* %oldcount, align 4
  %29 = load i32* %newcount, align 4
  %call22 = call i32 @atomic_cmpxchg(i32 %28, i32 %29)
  %call6 = call i32 @sleep(i32 1)
  store i32 %call22, i32* %updatedcount, align 4
  %30 = load i32* %updatedcount, align 4
  %31 = load i32* %oldcount, align 4
  %cmp23 = icmp eq i32 %30, %31
  br i1 %cmp23, label %if.then.25, label %if.end.41

if.then.25:                                       ; preds = %while.body
  %32 = load i32* %newcount, align 4
  %33 = load i32* @P, align 4
  %call1 = call i32 @sleep(i32 1)
  %cmp26 = icmp eq i32 %32, %33
  br i1 %cmp26, label %land.lhs.true, label %lor.lhs.false.30

land.lhs.true:                                    ; preds = %if.then.25
  %34 = load i32* %lsense, align 4
  %cmp28 = icmp eq i32 %34, 1
  br i1 %cmp28, label %if.then.36, label %lor.lhs.false.30

lor.lhs.false.30:                                 ; preds = %land.lhs.true, %if.then.25
  %35 = load i32* %newcount, align 4
  %cmp31 = icmp eq i32 %35, 0
  br i1 %cmp31, label %land.lhs.true.33, label %if.end.40

land.lhs.true.33:                                 ; preds = %lor.lhs.false.30
  %36 = load i32* %lsense, align 4
  %cmp34 = icmp eq i32 %36, -1
  br i1 %cmp34, label %if.then.36, label %if.end.40

if.then.36:                                       ; preds = %land.lhs.true.33, %land.lhs.true
  %37 = load i32* %lsense, align 4
  %sub37 = sub nsw i32 0, %37
  %38 = load %struct.GlobalMemory** @Global, align 8
  %start38 = getelementptr inbounds %struct.GlobalMemory* %38, i32 0, i32 10
  %gsense39 = getelementptr inbounds %struct.barrier_t* %start38, i32 0, i32 0
  call void @printX()
  store volatile i32 %sub37, i32* %gsense39, align 4
  call void @snapshot(i32 %sub37, i32 1)
  %call2 = call i32 @sleep(i32 3)
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.36, %land.lhs.true.33, %lor.lhs.false.30
  br label %while.end

if.end.41:                                        ; preds = %while.body
  br label %while.body

while.end:                                        ; preds = %if.end.40
  br label %while.cond

while.cond:                                       ; preds = %while.body.46, %while.end
  %39 = load %struct.GlobalMemory** @Global, align 8
  %start42 = getelementptr inbounds %struct.GlobalMemory* %39, i32 0, i32 10
  %gsense43 = getelementptr inbounds %struct.barrier_t* %start42, i32 0, i32 0
  %40 = load volatile i32* %gsense43, align 4
  %41 = load i32* %lsense, align 4
  %cmp44 = icmp eq i32 %40, %41
  br i1 %cmp44, label %while.body.46, label %while.end.47

while.body.46:                                    ; preds = %while.cond
  %call3 = call i32 @sleep(i32 2)
  br label %while.cond

while.end.47:                                     ; preds = %while.cond
  call void @printY()
  %call4 = call i32 @sleep(i32 1)
  br label %if.end.55

lor.lhs.false.50:                                 ; No predecessors!
  br label %if.end.55

if.then.52:                                       ; No predecessors!
  br label %if.end.55

if.end.55:                                        ; preds = %lor.lhs.false.50, %while.end.47, %if.then.52
  %42 = load i32* %K, align 4
  %43 = load i32* %K, align 4
  %44 = load i32* @nblocks, align 4
  %mul56 = mul nsw i32 %43, %44
  %add57 = add nsw i32 %42, %mul56
  %idxprom58 = sext i32 %add57 to i64
  %45 = load double*** @a, align 8
  %arrayidx59 = getelementptr inbounds double** %45, i64 %idxprom58
  %46 = load double** %arrayidx59, align 8
  store double* %46, double** %D, align 8
  %47 = load i32* %kl, align 4
  store i32 %47, i32* %i, align 4
  %48 = load i32* %K, align 4
  %add60 = add nsw i32 %48, 1
  store i32 %add60, i32* %I, align 4
  br label %for.cond.61

for.cond.61:                                      ; preds = %for.inc, %if.end.55
  %49 = load i32* %i, align 4
  %50 = load i32* %n.addr, align 4
  %cmp62 = icmp slt i32 %49, %50
  br i1 %cmp62, label %for.body.64, label %for.end

for.body.64:                                      ; preds = %for.cond.61
  %51 = load i32* %I, align 4
  %52 = load i32* %K, align 4
  %call65 = call i32 @BlockOwner(i32 %51, i32 %52)
  %53 = load i32* %MyNum.addr, align 4
  %cmp66 = icmp eq i32 %call65, %53
  br i1 %cmp66, label %if.then.68, label %if.end.80

if.then.68:                                       ; preds = %for.body.64
  %54 = load i32* %i, align 4
  %55 = load i32* %bs.addr, align 4
  %add69 = add nsw i32 %54, %55
  store i32 %add69, i32* %il, align 4
  %56 = load i32* %il, align 4
  %57 = load i32* %n.addr, align 4
  %cmp70 = icmp sgt i32 %56, %57
  br i1 %cmp70, label %if.then.72, label %if.else.74

if.then.72:                                       ; preds = %if.then.68
  %58 = load i32* %n.addr, align 4
  store i32 %58, i32* %il, align 4
  %59 = load i32* %il, align 4
  %60 = load i32* %i, align 4
  %sub73 = sub nsw i32 %59, %60
  store i32 %sub73, i32* %strI, align 4
  br label %if.end.75

if.else.74:                                       ; preds = %if.then.68
  %61 = load i32* %bs.addr, align 4
  store i32 %61, i32* %strI, align 4
  br label %if.end.75

if.end.75:                                        ; preds = %if.else.74, %if.then.72
  %62 = load i32* %I, align 4
  %63 = load i32* %K, align 4
  %64 = load i32* @nblocks, align 4
  %mul76 = mul nsw i32 %63, %64
  %add77 = add nsw i32 %62, %mul76
  %idxprom78 = sext i32 %add77 to i64
  %65 = load double*** @a, align 8
  %arrayidx79 = getelementptr inbounds double** %65, i64 %idxprom78
  %66 = load double** %arrayidx79, align 8
  store double* %66, double** %A, align 8
  %67 = load double** %A, align 8
  %68 = load double** %D, align 8
  %69 = load i32* %strI, align 4
  %70 = load i32* %strK, align 4
  %71 = load i32* %strI, align 4
  %72 = load i32* %strK, align 4
  call void @bdiv(double* %67, double* %68, i32 %69, i32 %70, i32 %71, i32 %72)
  br label %if.end.80

if.end.80:                                        ; preds = %if.end.75, %for.body.64
  br label %for.inc

for.inc:                                          ; preds = %if.end.80
  %73 = load i32* %bs.addr, align 4
  %74 = load i32* %i, align 4
  %add81 = add nsw i32 %74, %73
  store i32 %add81, i32* %i, align 4
  %75 = load i32* %I, align 4
  %inc = add nsw i32 %75, 1
  store i32 %inc, i32* %I, align 4
  br label %for.cond.61

for.end:                                          ; preds = %for.cond.61
  %76 = load i32* %kl, align 4
  store i32 %76, i32* %j, align 4
  %77 = load i32* %K, align 4
  %add82 = add nsw i32 %77, 1
  store i32 %add82, i32* %J, align 4
  br label %for.cond.83

for.cond.83:                                      ; preds = %for.inc.103, %for.end
  %78 = load i32* %j, align 4
  %79 = load i32* %n.addr, align 4
  %cmp84 = icmp slt i32 %78, %79
  br i1 %cmp84, label %for.body.86, label %for.end.106

for.body.86:                                      ; preds = %for.cond.83
  %80 = load i32* %K, align 4
  %81 = load i32* %J, align 4
  %call87 = call i32 @BlockOwner(i32 %80, i32 %81)
  %82 = load i32* %MyNum.addr, align 4
  %cmp88 = icmp eq i32 %call87, %82
  br i1 %cmp88, label %if.then.90, label %if.end.102

if.then.90:                                       ; preds = %for.body.86
  %83 = load i32* %j, align 4
  %84 = load i32* %bs.addr, align 4
  %add91 = add nsw i32 %83, %84
  store i32 %add91, i32* %jl, align 4
  %85 = load i32* %jl, align 4
  %86 = load i32* %n.addr, align 4
  %cmp92 = icmp sgt i32 %85, %86
  br i1 %cmp92, label %if.then.94, label %if.else.96

if.then.94:                                       ; preds = %if.then.90
  %87 = load i32* %n.addr, align 4
  store i32 %87, i32* %jl, align 4
  %88 = load i32* %jl, align 4
  %89 = load i32* %j, align 4
  %sub95 = sub nsw i32 %88, %89
  store i32 %sub95, i32* %strJ, align 4
  br label %if.end.97

if.else.96:                                       ; preds = %if.then.90
  %90 = load i32* %bs.addr, align 4
  store i32 %90, i32* %strJ, align 4
  br label %if.end.97

if.end.97:                                        ; preds = %if.else.96, %if.then.94
  %91 = load i32* %K, align 4
  %92 = load i32* %J, align 4
  %93 = load i32* @nblocks, align 4
  %mul98 = mul nsw i32 %92, %93
  %add99 = add nsw i32 %91, %mul98
  %idxprom100 = sext i32 %add99 to i64
  %94 = load double*** @a, align 8
  %arrayidx101 = getelementptr inbounds double** %94, i64 %idxprom100
  %95 = load double** %arrayidx101, align 8
  store double* %95, double** %A, align 8
  %96 = load double** %D, align 8
  %97 = load double** %A, align 8
  %98 = load i32* %strK, align 4
  %99 = load i32* %strJ, align 4
  %100 = load i32* %strK, align 4
  %101 = load i32* %strK, align 4
  call void @bmodd(double* %96, double* %97, i32 %98, i32 %99, i32 %100, i32 %101)
  br label %if.end.102

if.end.102:                                       ; preds = %if.end.97, %for.body.86
  br label %for.inc.103

for.inc.103:                                      ; preds = %if.end.102
  %102 = load i32* %bs.addr, align 4
  %103 = load i32* %j, align 4
  %add104 = add nsw i32 %103, %102
  store i32 %add104, i32* %j, align 4
  %104 = load i32* %J, align 4
  %inc105 = add nsw i32 %104, 1
  store i32 %inc105, i32* %J, align 4
  br label %for.cond.83

for.end.106:                                      ; preds = %for.cond.83
  br label %if.end.114

lor.lhs.false.109:                                ; No predecessors!
  br label %if.end.114

if.then.111:                                      ; No predecessors!
  br label %if.end.114

if.end.114:                                       ; preds = %lor.lhs.false.109, %for.end.106, %if.then.111
  %105 = load %struct.GlobalMemory** @Global, align 8
  %start116 = getelementptr inbounds %struct.GlobalMemory* %105, i32 0, i32 10
  %gsense117 = getelementptr inbounds %struct.barrier_t* %start116, i32 0, i32 0
  call void @printChar(i8 signext 53)
  call void @printChar(i8 signext 90)
  call void @InitializeSwitchesAndCounter()
  call void @IncrementCounter()
  %106 = load volatile i32* %gsense117, align 4
  store i32 %106, i32* %lsense115, align 4
  br label %while.body.119

while.body.119:                                   ; preds = %if.end.148, %if.end.114
  %107 = load %struct.GlobalMemory** @Global, align 8
  %start121 = getelementptr inbounds %struct.GlobalMemory* %107, i32 0, i32 10
  %count122 = getelementptr inbounds %struct.barrier_t* %start121, i32 0, i32 1
  %108 = load volatile i64* %count122, align 8
  %call7 = call i32 @sleep(i32 1)
  %conv123 = trunc i64 %108 to i32
  store i32 %conv123, i32* %oldcount120, align 4
  %109 = load i32* %oldcount120, align 4
  %110 = load i32* %lsense115, align 4
  %add125 = add nsw i32 %109, %110
  store i32 %add125, i32* %newcount124, align 4
  %111 = load i32* %oldcount120, align 4
  %112 = load i32* %newcount124, align 4
  %call128 = call i32 @atomic_cmpxchg(i32 %111, i32 %112)
  %call12 = call i32 @sleep(i32 1)
  store i32 %call128, i32* %updatedcount126, align 4
  %113 = load i32* %updatedcount126, align 4
  %114 = load i32* %oldcount120, align 4
  %cmp129 = icmp eq i32 %113, %114
  br i1 %cmp129, label %if.then.131, label %if.end.148

if.then.131:                                      ; preds = %while.body.119
  %115 = load i32* %newcount124, align 4
  %116 = load i32* @P, align 4
  %call8 = call i32 @sleep(i32 1)
  %cmp132 = icmp eq i32 %115, %116
  br i1 %cmp132, label %land.lhs.true.134, label %lor.lhs.false.137

land.lhs.true.134:                                ; preds = %if.then.131
  %117 = load i32* %lsense115, align 4
  %cmp135 = icmp eq i32 %117, 1
  br i1 %cmp135, label %if.then.143, label %lor.lhs.false.137

lor.lhs.false.137:                                ; preds = %land.lhs.true.134, %if.then.131
  %118 = load i32* %newcount124, align 4
  %cmp138 = icmp eq i32 %118, 0
  br i1 %cmp138, label %land.lhs.true.140, label %if.end.147

land.lhs.true.140:                                ; preds = %lor.lhs.false.137
  %119 = load i32* %lsense115, align 4
  %cmp141 = icmp eq i32 %119, -1
  br i1 %cmp141, label %if.then.143, label %if.end.147

if.then.143:                                      ; preds = %land.lhs.true.140, %land.lhs.true.134
  %120 = load i32* %lsense115, align 4
  %sub144 = sub nsw i32 0, %120
  %121 = load %struct.GlobalMemory** @Global, align 8
  %start145 = getelementptr inbounds %struct.GlobalMemory* %121, i32 0, i32 10
  %gsense146 = getelementptr inbounds %struct.barrier_t* %start145, i32 0, i32 0
  call void @printX()
  store volatile i32 %sub144, i32* %gsense146, align 4
  call void @snapshot(i32 %sub144, i32 1)
  %call9 = call i32 @sleep(i32 3)
  br label %if.end.147

if.end.147:                                       ; preds = %if.then.143, %land.lhs.true.140, %lor.lhs.false.137
  br label %while.end.149

if.end.148:                                       ; preds = %while.body.119
  br label %while.body.119

while.end.149:                                    ; preds = %if.end.147
  br label %while.cond.150

while.cond.150:                                   ; preds = %while.body.155, %while.end.149
  %122 = load %struct.GlobalMemory** @Global, align 8
  %start151 = getelementptr inbounds %struct.GlobalMemory* %122, i32 0, i32 10
  %gsense152 = getelementptr inbounds %struct.barrier_t* %start151, i32 0, i32 0
  %123 = load volatile i32* %gsense152, align 4
  %124 = load i32* %lsense115, align 4
  %cmp153 = icmp eq i32 %123, %124
  br i1 %cmp153, label %while.body.155, label %while.end.156

while.body.155:                                   ; preds = %while.cond.150
  %call10 = call i32 @sleep(i32 2)
  br label %while.cond.150

while.end.156:                                    ; preds = %while.cond.150
  call void @printY()
  %call11 = call i32 @sleep(i32 1)
  br label %if.end.164

lor.lhs.false.159:                                ; No predecessors!
  br label %if.end.164

if.then.161:                                      ; No predecessors!
  br label %if.end.164

if.end.164:                                       ; preds = %lor.lhs.false.159, %while.end.156, %if.then.161
  %125 = load i32* %kl, align 4
  store i32 %125, i32* %i, align 4
  %126 = load i32* %K, align 4
  %add165 = add nsw i32 %126, 1
  store i32 %add165, i32* %I, align 4
  br label %for.cond.166

for.cond.166:                                     ; preds = %for.inc.211, %if.end.164
  %127 = load i32* %i, align 4
  %128 = load i32* %n.addr, align 4
  %cmp167 = icmp slt i32 %127, %128
  br i1 %cmp167, label %for.body.169, label %for.end.214

for.body.169:                                     ; preds = %for.cond.166
  %129 = load i32* %i, align 4
  %130 = load i32* %bs.addr, align 4
  %add170 = add nsw i32 %129, %130
  store i32 %add170, i32* %il, align 4
  %131 = load i32* %il, align 4
  %132 = load i32* %n.addr, align 4
  %cmp171 = icmp sgt i32 %131, %132
  br i1 %cmp171, label %if.then.173, label %if.else.175

if.then.173:                                      ; preds = %for.body.169
  %133 = load i32* %n.addr, align 4
  store i32 %133, i32* %il, align 4
  %134 = load i32* %il, align 4
  %135 = load i32* %i, align 4
  %sub174 = sub nsw i32 %134, %135
  store i32 %sub174, i32* %strI, align 4
  br label %if.end.176

if.else.175:                                      ; preds = %for.body.169
  %136 = load i32* %bs.addr, align 4
  store i32 %136, i32* %strI, align 4
  br label %if.end.176

if.end.176:                                       ; preds = %if.else.175, %if.then.173
  %137 = load i32* %I, align 4
  %138 = load i32* %K, align 4
  %call177 = call i32 @BlockOwner(i32 %137, i32 %138)
  %139 = load i32* %I, align 4
  %140 = load i32* %K, align 4
  %141 = load i32* @nblocks, align 4
  %mul178 = mul nsw i32 %140, %141
  %add179 = add nsw i32 %139, %mul178
  %idxprom180 = sext i32 %add179 to i64
  %142 = load double*** @a, align 8
  %arrayidx181 = getelementptr inbounds double** %142, i64 %idxprom180
  %143 = load double** %arrayidx181, align 8
  store double* %143, double** %A, align 8
  %144 = load i32* %kl, align 4
  store i32 %144, i32* %j, align 4
  %145 = load i32* %K, align 4
  %add182 = add nsw i32 %145, 1
  store i32 %add182, i32* %J, align 4
  br label %for.cond.183

for.cond.183:                                     ; preds = %for.inc.207, %if.end.176
  %146 = load i32* %j, align 4
  %147 = load i32* %n.addr, align 4
  %cmp184 = icmp slt i32 %146, %147
  br i1 %cmp184, label %for.body.186, label %for.end.210

for.body.186:                                     ; preds = %for.cond.183
  %148 = load i32* %j, align 4
  %149 = load i32* %bs.addr, align 4
  %add187 = add nsw i32 %148, %149
  store i32 %add187, i32* %jl, align 4
  %150 = load i32* %jl, align 4
  %151 = load i32* %n.addr, align 4
  %cmp188 = icmp sgt i32 %150, %151
  br i1 %cmp188, label %if.then.190, label %if.else.192

if.then.190:                                      ; preds = %for.body.186
  %152 = load i32* %n.addr, align 4
  store i32 %152, i32* %jl, align 4
  %153 = load i32* %jl, align 4
  %154 = load i32* %j, align 4
  %sub191 = sub nsw i32 %153, %154
  store i32 %sub191, i32* %strJ, align 4
  br label %if.end.193

if.else.192:                                      ; preds = %for.body.186
  %155 = load i32* %bs.addr, align 4
  store i32 %155, i32* %strJ, align 4
  br label %if.end.193

if.end.193:                                       ; preds = %if.else.192, %if.then.190
  %156 = load i32* %I, align 4
  %157 = load i32* %J, align 4
  %call194 = call i32 @BlockOwner(i32 %156, i32 %157)
  %158 = load i32* %MyNum.addr, align 4
  %cmp195 = icmp eq i32 %call194, %158
  br i1 %cmp195, label %if.then.197, label %if.end.206

if.then.197:                                      ; preds = %if.end.193
  %159 = load i32* %K, align 4
  %160 = load i32* %J, align 4
  %161 = load i32* @nblocks, align 4
  %mul198 = mul nsw i32 %160, %161
  %add199 = add nsw i32 %159, %mul198
  %idxprom200 = sext i32 %add199 to i64
  %162 = load double*** @a, align 8
  %arrayidx201 = getelementptr inbounds double** %162, i64 %idxprom200
  %163 = load double** %arrayidx201, align 8
  store double* %163, double** %B, align 8
  %164 = load i32* %I, align 4
  %165 = load i32* %J, align 4
  %166 = load i32* @nblocks, align 4
  %mul202 = mul nsw i32 %165, %166
  %add203 = add nsw i32 %164, %mul202
  %idxprom204 = sext i32 %add203 to i64
  %167 = load double*** @a, align 8
  %arrayidx205 = getelementptr inbounds double** %167, i64 %idxprom204
  %168 = load double** %arrayidx205, align 8
  store double* %168, double** %C, align 8
  %169 = load double** %A, align 8
  %170 = load double** %B, align 8
  %171 = load double** %C, align 8
  %172 = load i32* %strI, align 4
  %173 = load i32* %strJ, align 4
  %174 = load i32* %strK, align 4
  %175 = load i32* %strI, align 4
  %176 = load i32* %strK, align 4
  %177 = load i32* %strI, align 4
  call void @bmod(double* %169, double* %170, double* %171, i32 %172, i32 %173, i32 %174, i32 %175, i32 %176, i32 %177)
  br label %if.end.206

if.end.206:                                       ; preds = %if.then.197, %if.end.193
  br label %for.inc.207

for.inc.207:                                      ; preds = %if.end.206
  %178 = load i32* %bs.addr, align 4
  %179 = load i32* %j, align 4
  %add208 = add nsw i32 %179, %178
  store i32 %add208, i32* %j, align 4
  %180 = load i32* %J, align 4
  %inc209 = add nsw i32 %180, 1
  store i32 %inc209, i32* %J, align 4
  br label %for.cond.183

for.end.210:                                      ; preds = %for.cond.183
  br label %for.inc.211

for.inc.211:                                      ; preds = %for.end.210
  %181 = load i32* %bs.addr, align 4
  %182 = load i32* %i, align 4
  %add212 = add nsw i32 %182, %181
  store i32 %add212, i32* %i, align 4
  %183 = load i32* %I, align 4
  %inc213 = add nsw i32 %183, 1
  store i32 %inc213, i32* %I, align 4
  br label %for.cond.166

for.end.214:                                      ; preds = %for.cond.166
  br label %if.end.236

lor.lhs.false.217:                                ; No predecessors!
  br label %if.end.236

if.then.219:                                      ; No predecessors!
  br label %if.end.236

if.end.236:                                       ; preds = %lor.lhs.false.217, %for.end.214, %if.then.219
  br label %for.inc.237

for.inc.237:                                      ; preds = %if.end.236
  %184 = load i32* %bs.addr, align 4
  %185 = load i32* %k, align 4
  %add238 = add nsw i32 %185, %184
  store i32 %add238, i32* %k, align 4
  %186 = load i32* %K, align 4
  %inc239 = add nsw i32 %186, 1
  store i32 %inc239, i32* %K, align 4
  br label %for.cond

for.end.240:                                      ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @lu0(double* %a, i32 %n, i32 %stride) {
entry:
  %a.addr = alloca double*, align 8
  %n.addr = alloca i32, align 4
  %stride.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %length = alloca i32, align 4
  %alpha = alloca double, align 8
  store double* %a, double** %a.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i32 %stride, i32* %stride.addr, align 4
  store i32 0, i32* %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.27, %entry
  %0 = load i32* %k, align 4
  %1 = load i32* %n.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end.29

for.body:                                         ; preds = %for.cond
  %2 = load i32* %k, align 4
  %add = add nsw i32 %2, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond.1

for.cond.1:                                       ; preds = %for.inc, %for.body
  %3 = load i32* %j, align 4
  %4 = load i32* %n.addr, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body.3, label %for.end

for.body.3:                                       ; preds = %for.cond.1
  %5 = load i32* %k, align 4
  %6 = load i32* %k, align 4
  %7 = load i32* %stride.addr, align 4
  %mul = mul nsw i32 %6, %7
  %add4 = add nsw i32 %5, %mul
  %idxprom = sext i32 %add4 to i64
  %8 = load double** %a.addr, align 8
  %arrayidx = getelementptr inbounds double* %8, i64 %idxprom
  %9 = load double* %arrayidx, align 8
  %10 = load i32* %k, align 4
  %11 = load i32* %j, align 4
  %12 = load i32* %stride.addr, align 4
  %mul5 = mul nsw i32 %11, %12
  %add6 = add nsw i32 %10, %mul5
  %idxprom7 = sext i32 %add6 to i64
  %13 = load double** %a.addr, align 8
  %arrayidx8 = getelementptr inbounds double* %13, i64 %idxprom7
  %14 = load double* %arrayidx8, align 8
  %div = fdiv double %14, %9
  store double %div, double* %arrayidx8, align 8
  %15 = load i32* %k, align 4
  %16 = load i32* %j, align 4
  %17 = load i32* %stride.addr, align 4
  %mul9 = mul nsw i32 %16, %17
  %add10 = add nsw i32 %15, %mul9
  %idxprom11 = sext i32 %add10 to i64
  %18 = load double** %a.addr, align 8
  %arrayidx12 = getelementptr inbounds double* %18, i64 %idxprom11
  %19 = load double* %arrayidx12, align 8
  %sub = fsub double -0.000000e+00, %19
  store double %sub, double* %alpha, align 8
  %20 = load i32* %k, align 4
  %add15 = add nsw i32 %20, 1
  %21 = load i32* %j, align 4
  %22 = load i32* %stride.addr, align 4
  %mul16 = mul nsw i32 %21, %22
  %add17 = add nsw i32 %add15, %mul16
  %idxprom18 = sext i32 %add17 to i64
  %23 = load double** %a.addr, align 8
  %arrayidx19 = getelementptr inbounds double* %23, i64 %idxprom18
  %24 = load i32* %k, align 4
  %add20 = add nsw i32 %24, 1
  %25 = load i32* %k, align 4
  %26 = load i32* %stride.addr, align 4
  %mul21 = mul nsw i32 %25, %26
  %add22 = add nsw i32 %add20, %mul21
  %idxprom23 = sext i32 %add22 to i64
  %27 = load double** %a.addr, align 8
  %arrayidx24 = getelementptr inbounds double* %27, i64 %idxprom23
  %28 = load i32* %n.addr, align 4
  %29 = load i32* %k, align 4
  %sub25 = sub nsw i32 %28, %29
  %sub26 = sub nsw i32 %sub25, 1
  %30 = load double* %alpha, align 8
  call void @daxpy(double* %arrayidx19, double* %arrayidx24, i32 %sub26, double %30)
  br label %for.inc

for.inc:                                          ; preds = %for.body.3
  %31 = load i32* %j, align 4
  %inc = add nsw i32 %31, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond.1

for.end:                                          ; preds = %for.cond.1
  br label %for.inc.27

for.inc.27:                                       ; preds = %for.end
  %32 = load i32* %k, align 4
  %inc28 = add nsw i32 %32, 1
  store i32 %inc28, i32* %k, align 4
  br label %for.cond

for.end.29:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @daxpy(double* %a, double* %b, i32 %n, double %alpha) {
entry:
  %a.addr = alloca double*, align 8
  %b.addr = alloca double*, align 8
  %n.addr = alloca i32, align 4
  %alpha.addr = alloca double, align 8
  %i = alloca i32, align 4
  store double* %a, double** %a.addr, align 8
  store double* %b, double** %b.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store double %alpha, double* %alpha.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load i32* %n.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load double* %alpha.addr, align 8
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load double** %b.addr, align 8
  %arrayidx = getelementptr inbounds double* %4, i64 %idxprom
  %5 = load double* %arrayidx, align 8
  %mul = fmul double %2, %5
  %6 = load i32* %i, align 4
  %idxprom1 = sext i32 %6 to i64
  %7 = load double** %a.addr, align 8
  %arrayidx2 = getelementptr inbounds double* %7, i64 %idxprom1
  %8 = load double* %arrayidx2, align 8
  %add = fadd double %8, %mul
  store double %add, double* %arrayidx2, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @bdiv(double* %a, double* %diag, i32 %stride_a, i32 %stride_diag, i32 %dimi, i32 %dimk) {
entry:
  %a.addr = alloca double*, align 8
  %diag.addr = alloca double*, align 8
  %stride_a.addr = alloca i32, align 4
  %stride_diag.addr = alloca i32, align 4
  %dimi.addr = alloca i32, align 4
  %dimk.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %alpha = alloca double, align 8
  store double* %a, double** %a.addr, align 8
  store double* %diag, double** %diag.addr, align 8
  store i32 %stride_a, i32* %stride_a.addr, align 4
  store i32 %stride_diag, i32* %stride_diag.addr, align 4
  store i32 %dimi, i32* %dimi.addr, align 4
  store i32 %dimk, i32* %dimk.addr, align 4
  store i32 0, i32* %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.11, %entry
  %0 = load i32* %k, align 4
  %1 = load i32* %dimk.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end.13

for.body:                                         ; preds = %for.cond
  %2 = load i32* %k, align 4
  %add = add nsw i32 %2, 1
  store i32 %add, i32* %j, align 4
  br label %for.cond.1

for.cond.1:                                       ; preds = %for.inc, %for.body
  %3 = load i32* %j, align 4
  %4 = load i32* %dimk.addr, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body.3, label %for.end

for.body.3:                                       ; preds = %for.cond.1
  %5 = load i32* %k, align 4
  %6 = load i32* %j, align 4
  %7 = load i32* %stride_diag.addr, align 4
  %mul = mul nsw i32 %6, %7
  %add4 = add nsw i32 %5, %mul
  %idxprom = sext i32 %add4 to i64
  %8 = load double** %diag.addr, align 8
  %arrayidx = getelementptr inbounds double* %8, i64 %idxprom
  %9 = load double* %arrayidx, align 8
  %sub = fsub double -0.000000e+00, %9
  store double %sub, double* %alpha, align 8
  %10 = load i32* %j, align 4
  %11 = load i32* %stride_a.addr, align 4
  %mul5 = mul nsw i32 %10, %11
  %idxprom6 = sext i32 %mul5 to i64
  %12 = load double** %a.addr, align 8
  %arrayidx7 = getelementptr inbounds double* %12, i64 %idxprom6
  %13 = load i32* %k, align 4
  %14 = load i32* %stride_a.addr, align 4
  %mul8 = mul nsw i32 %13, %14
  %idxprom9 = sext i32 %mul8 to i64
  %15 = load double** %a.addr, align 8
  %arrayidx10 = getelementptr inbounds double* %15, i64 %idxprom9
  %16 = load i32* %dimi.addr, align 4
  %17 = load double* %alpha, align 8
  call void @daxpy(double* %arrayidx7, double* %arrayidx10, i32 %16, double %17)
  br label %for.inc

for.inc:                                          ; preds = %for.body.3
  %18 = load i32* %j, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond.1

for.end:                                          ; preds = %for.cond.1
  br label %for.inc.11

for.inc.11:                                       ; preds = %for.end
  %19 = load i32* %k, align 4
  %inc12 = add nsw i32 %19, 1
  store i32 %inc12, i32* %k, align 4
  br label %for.cond

for.end.13:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @bmodd(double* %a, double* %c, i32 %dimi, i32 %dimj, i32 %stride_a, i32 %stride_c) {
entry:
  %a.addr = alloca double*, align 8
  %c.addr = alloca double*, align 8
  %dimi.addr = alloca i32, align 4
  %dimj.addr = alloca i32, align 4
  %stride_a.addr = alloca i32, align 4
  %stride_c.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %length = alloca i32, align 4
  %alpha = alloca double, align 8
  store double* %a, double** %a.addr, align 8
  store double* %c, double** %c.addr, align 8
  store i32 %dimi, i32* %dimi.addr, align 4
  store i32 %dimj, i32* %dimj.addr, align 4
  store i32 %stride_a, i32* %stride_a.addr, align 4
  store i32 %stride_c, i32* %stride_c.addr, align 4
  store i32 0, i32* %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.26, %entry
  %0 = load i32* %k, align 4
  %1 = load i32* %dimi.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end.28

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond.1

for.cond.1:                                       ; preds = %for.inc, %for.body
  %2 = load i32* %j, align 4
  %3 = load i32* %dimj.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body.3, label %for.end

for.body.3:                                       ; preds = %for.cond.1
  %4 = load i32* %k, align 4
  %5 = load i32* %k, align 4
  %6 = load i32* %stride_a.addr, align 4
  %mul = mul nsw i32 %5, %6
  %add = add nsw i32 %4, %mul
  %idxprom = sext i32 %add to i64
  %7 = load double** %a.addr, align 8
  %arrayidx = getelementptr inbounds double* %7, i64 %idxprom
  %8 = load double* %arrayidx, align 8
  %9 = load i32* %k, align 4
  %10 = load i32* %j, align 4
  %11 = load i32* %stride_c.addr, align 4
  %mul4 = mul nsw i32 %10, %11
  %add5 = add nsw i32 %9, %mul4
  %idxprom6 = sext i32 %add5 to i64
  %12 = load double** %c.addr, align 8
  %arrayidx7 = getelementptr inbounds double* %12, i64 %idxprom6
  %13 = load double* %arrayidx7, align 8
  %div = fdiv double %13, %8
  store double %div, double* %arrayidx7, align 8
  %14 = load i32* %k, align 4
  %15 = load i32* %j, align 4
  %16 = load i32* %stride_c.addr, align 4
  %mul8 = mul nsw i32 %15, %16
  %add9 = add nsw i32 %14, %mul8
  %idxprom10 = sext i32 %add9 to i64
  %17 = load double** %c.addr, align 8
  %arrayidx11 = getelementptr inbounds double* %17, i64 %idxprom10
  %18 = load double* %arrayidx11, align 8
  %sub = fsub double -0.000000e+00, %18
  store double %sub, double* %alpha, align 8
  %19 = load i32* %k, align 4
  %add14 = add nsw i32 %19, 1
  %20 = load i32* %j, align 4
  %21 = load i32* %stride_c.addr, align 4
  %mul15 = mul nsw i32 %20, %21
  %add16 = add nsw i32 %add14, %mul15
  %idxprom17 = sext i32 %add16 to i64
  %22 = load double** %c.addr, align 8
  %arrayidx18 = getelementptr inbounds double* %22, i64 %idxprom17
  %23 = load i32* %k, align 4
  %add19 = add nsw i32 %23, 1
  %24 = load i32* %k, align 4
  %25 = load i32* %stride_a.addr, align 4
  %mul20 = mul nsw i32 %24, %25
  %add21 = add nsw i32 %add19, %mul20
  %idxprom22 = sext i32 %add21 to i64
  %26 = load double** %a.addr, align 8
  %arrayidx23 = getelementptr inbounds double* %26, i64 %idxprom22
  %27 = load i32* %dimi.addr, align 4
  %28 = load i32* %k, align 4
  %sub24 = sub nsw i32 %27, %28
  %sub25 = sub nsw i32 %sub24, 1
  %29 = load double* %alpha, align 8
  call void @daxpy(double* %arrayidx18, double* %arrayidx23, i32 %sub25, double %29)
  br label %for.inc

for.inc:                                          ; preds = %for.body.3
  %30 = load i32* %j, align 4
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond.1

for.end:                                          ; preds = %for.cond.1
  br label %for.inc.26

for.inc.26:                                       ; preds = %for.end
  %31 = load i32* %k, align 4
  %inc27 = add nsw i32 %31, 1
  store i32 %inc27, i32* %k, align 4
  br label %for.cond

for.end.28:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @bmod(double* %a, double* %b, double* %c, i32 %dimi, i32 %dimj, i32 %dimk, i32 %stridea, i32 %strideb, i32 %stridec) {
entry:
  %a.addr = alloca double*, align 8
  %b.addr = alloca double*, align 8
  %c.addr = alloca double*, align 8
  %dimi.addr = alloca i32, align 4
  %dimj.addr = alloca i32, align 4
  %dimk.addr = alloca i32, align 4
  %stridea.addr = alloca i32, align 4
  %strideb.addr = alloca i32, align 4
  %stridec.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %alpha = alloca double, align 8
  store double* %a, double** %a.addr, align 8
  store double* %b, double** %b.addr, align 8
  store double* %c, double** %c.addr, align 8
  store i32 %dimi, i32* %dimi.addr, align 4
  store i32 %dimj, i32* %dimj.addr, align 4
  store i32 %dimk, i32* %dimk.addr, align 4
  store i32 %stridea, i32* %stridea.addr, align 4
  store i32 %strideb, i32* %strideb.addr, align 4
  store i32 %stridec, i32* %stridec.addr, align 4
  store i32 0, i32* %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.10, %entry
  %0 = load i32* %k, align 4
  %1 = load i32* %dimk.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end.12

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond.1

for.cond.1:                                       ; preds = %for.inc, %for.body
  %2 = load i32* %j, align 4
  %3 = load i32* %dimj.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body.3, label %for.end

for.body.3:                                       ; preds = %for.cond.1
  %4 = load i32* %k, align 4
  %5 = load i32* %j, align 4
  %6 = load i32* %strideb.addr, align 4
  %mul = mul nsw i32 %5, %6
  %add = add nsw i32 %4, %mul
  %idxprom = sext i32 %add to i64
  %7 = load double** %b.addr, align 8
  %arrayidx = getelementptr inbounds double* %7, i64 %idxprom
  %8 = load double* %arrayidx, align 8
  %sub = fsub double -0.000000e+00, %8
  store double %sub, double* %alpha, align 8
  %9 = load i32* %j, align 4
  %10 = load i32* %stridec.addr, align 4
  %mul4 = mul nsw i32 %9, %10
  %idxprom5 = sext i32 %mul4 to i64
  %11 = load double** %c.addr, align 8
  %arrayidx6 = getelementptr inbounds double* %11, i64 %idxprom5
  %12 = load i32* %k, align 4
  %13 = load i32* %stridea.addr, align 4
  %mul7 = mul nsw i32 %12, %13
  %idxprom8 = sext i32 %mul7 to i64
  %14 = load double** %a.addr, align 8
  %arrayidx9 = getelementptr inbounds double* %14, i64 %idxprom8
  %15 = load i32* %dimi.addr, align 4
  %16 = load double* %alpha, align 8
  call void @daxpy(double* %arrayidx6, double* %arrayidx9, i32 %15, double %16)
  br label %for.inc

for.inc:                                          ; preds = %for.body.3
  %17 = load i32* %j, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond.1

for.end:                                          ; preds = %for.cond.1
  br label %for.inc.10

for.inc.10:                                       ; preds = %for.end
  %18 = load i32* %k, align 4
  %inc11 = add nsw i32 %18, 1
  store i32 %inc11, i32* %k, align 4
  br label %for.cond

for.end.12:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind
declare void @srand48(i64)

; Function Attrs: nounwind
declare i64 @lrand48()

; Function Attrs: nounwind uwtable
define internal void @PrintA() {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %ii = alloca i32, align 4
  %jj = alloca i32, align 4
  %edge = alloca i32, align 4
  %ibs = alloca i32, align 4
  %jbs = alloca i32, align 4
  %skip = alloca i32, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.20, %entry
  br label %for.end.22

for.body:                                         ; No predecessors!
  br label %for.cond.1

for.cond.1:                                       ; preds = %for.inc, %for.body
  br label %for.end

for.body.3:                                       ; No predecessors!
  br label %if.end

if.then:                                          ; No predecessors!
  br label %if.end

if.else:                                          ; No predecessors!
  br label %if.end

if.end:                                           ; preds = %for.body.3, %if.else, %if.then
  br label %if.end.11

if.then.8:                                        ; No predecessors!
  br label %if.end.11

if.else.10:                                       ; No predecessors!
  br label %if.end.11

if.end.11:                                        ; preds = %if.end, %if.else.10, %if.then.8
  br label %for.inc

for.inc:                                          ; preds = %if.end.11
  br label %for.cond.1

for.end:                                          ; preds = %for.cond.1
  br label %for.inc.20

for.inc.20:                                       ; preds = %for.end
  br label %for.cond

for.end.22:                                       ; preds = %for.cond
  ret void
}

declare i32 @fflush(%struct._IO_FILE*)

; Function Attrs: nounwind readnone
declare double @fabs(double)

; Function Attrs: nounwind
declare void @free(i8*)

; Function Attrs: nounwind uwtable
define internal void @DeriveInvariant() {
entry:
  ret void
}

define internal void @printX() {
entry:
  %0 = load i32* @index_out, align 4
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [200 x i8]* @mystring, i32 0, i64 %idxprom
  store i8 88, i8* %arrayidx, align 1
  %1 = load i32* @index_out, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* @index_out, align 4
  ret void
}

define internal void @printY() {
entry:
  %0 = load i32* @index_out, align 4
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [200 x i8]* @mystring, i32 0, i64 %idxprom
  store i8 89, i8* %arrayidx, align 1
  %1 = load i32* @index_out, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* @index_out, align 4
  call void @DecrementCounter()
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DecrementCounter() {
entry:
  %idx = alloca i32, align 4
  %i = alloca i32, align 4
  %i13 = alloca i32, align 4
  %call = call i32 (...) *@pthread_self()
  store i32 %call, i32* %idx, align 4
  %0 = load i32* %idx, align 4
  %idxprom = zext i32 %0 to i64
  %arrayidx = getelementptr inbounds [3 x i8]* @switches, i32 0, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1
  %1 = load i32* %idx, align 4
  %idxprom1 = zext i32 %1 to i64
  %arrayidx2 = getelementptr inbounds [3 x i32]* @syncID, i32 0, i64 %idxprom1
  %2 = load i32* %arrayidx2, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i32* @counter0, align 4
  %dec = add nsw i32 %3, -1
  store i32 %dec, i32* @counter0, align 4
  %4 = load i32* @counter0, align 4
  %cmp3 = icmp eq i32 %4, 0
  br i1 %cmp3, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %if.then
  call void @DeriveInvariant()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.4
  %5 = load i32* %i, align 4
  %cmp5 = icmp slt i32 %5, 3
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32* %i, align 4
  %idxprom6 = sext i32 %6 to i64
  %arrayidx7 = getelementptr inbounds [3 x i8]* @switches, i32 0, i64 %idxprom6
  store i8 1, i8* %arrayidx7, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32* %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %if.then
  %8 = load i32* %idx, align 4
  %idxprom8 = zext i32 %8 to i64
  %arrayidx9 = getelementptr inbounds [3 x i32]* @syncID, i32 0, i64 %idxprom8
  store i32 1, i32* %arrayidx9, align 4
  br label %if.end.25

if.else:                                          ; preds = %entry
  %9 = load i32* @counter1, align 4
  %dec10 = add nsw i32 %9, -1
  store i32 %dec10, i32* @counter1, align 4
  %10 = load i32* @counter1, align 4
  %cmp11 = icmp eq i32 %10, 0
  br i1 %cmp11, label %if.then.12, label %if.end.22

if.then.12:                                       ; preds = %if.else
  call void @DeriveInvariant()
  store i32 0, i32* %i13, align 4
  br label %for.cond.14

for.cond.14:                                      ; preds = %for.inc.19, %if.then.12
  %11 = load i32* %i13, align 4
  %cmp15 = icmp slt i32 %11, 3
  br i1 %cmp15, label %for.body.16, label %for.end.21

for.body.16:                                      ; preds = %for.cond.14
  %12 = load i32* %i13, align 4
  %idxprom17 = sext i32 %12 to i64
  %arrayidx18 = getelementptr inbounds [3 x i8]* @switches, i32 0, i64 %idxprom17
  store i8 1, i8* %arrayidx18, align 1
  br label %for.inc.19

for.inc.19:                                       ; preds = %for.body.16
  %13 = load i32* %i13, align 4
  %inc20 = add nsw i32 %13, 1
  store i32 %inc20, i32* %i13, align 4
  br label %for.cond.14

for.end.21:                                       ; preds = %for.cond.14
  br label %if.end.22

if.end.22:                                        ; preds = %for.end.21, %if.else
  %14 = load i32* %idx, align 4
  %idxprom23 = zext i32 %14 to i64
  %arrayidx24 = getelementptr inbounds [3 x i32]* @syncID, i32 0, i64 %idxprom23
  store i32 0, i32* %arrayidx24, align 4
  br label %if.end.25

if.end.25:                                        ; preds = %if.end.22, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @flushAll() {
entry:
  %0 = load i32* @index_out, align 4
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [200 x i8]* @mystring, i32 0, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1
  ret void
}

define internal void @printChar(i8 signext %ch) {
entry:
  %ch.addr = alloca i8, align 1
  store i8 %ch, i8* %ch.addr, align 1
  %0 = load i8* %ch.addr, align 1
  %1 = load i32* @index_out, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [200 x i8]* @mystring, i32 0, i64 %idxprom
  store i8 %0, i8* %arrayidx, align 1
  %2 = load i32* @index_out, align 4
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* @index_out, align 4
  ret void
}

define internal void @waitForAll() {
entry:
  %call = call i32 (i32, i32, ...) *bitcast (i32 (...)* @pthread_join to i32 (i32, i32, ...)*)(i32 0, i32 0)
  call void @flushAll()
  ret void
}

declare i32 @pthread_join(...)

; Function Attrs: nounwind uwtable
define internal void @snapshot(i32 %gvar, i32 %index) {
entry:
  %gvar.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %idx = alloca i32, align 4
  store i32 %gvar, i32* %gvar.addr, align 4
  store i32 %index, i32* %index.addr, align 4
  %call = call i32 (...) *@pthread_self()
  store i32 %call, i32* %idx, align 4
  %0 = load i32* %idx, align 4
  %idxprom = zext i32 %0 to i64
  %arrayidx = getelementptr inbounds [3 x i8]* @switches, i32 0, i64 %idxprom
  %1 = load i8* %arrayidx, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.end.5

if.then:                                          ; preds = %entry
  %2 = load i32* %index.addr, align 4
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.1
    i32 2, label %sw.bb.2
  ]

sw.bb:                                            ; preds = %if.then
  %3 = load i32* %gvar.addr, align 4
  store i32 %3, i32* @gSyncVar_0, align 4
  br label %sw.epilog

sw.bb.1:                                          ; preds = %if.then
  %4 = load i32* %gvar.addr, align 4
  store i32 %4, i32* @gSyncVar_1, align 4
  br label %sw.epilog

sw.bb.2:                                          ; preds = %if.then
  %5 = load i32* %gvar.addr, align 4
  store i32 %5, i32* @gSyncVar_2, align 4
  br label %sw.default

sw.default:                                       ; preds = %sw.bb.2, %if.then
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb.1, %sw.bb
  %6 = load i32* %index.addr, align 4
  %add = add nsw i32 %6, 1
  %7 = load i32* @gSyncVarsTotalNum, align 4
  %cmp = icmp sgt i32 %add, %7
  br i1 %cmp, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %sw.epilog
  %8 = load i32* %index.addr, align 4
  %add4 = add nsw i32 %8, 1
  store i32 %add4, i32* @gSyncVarsTotalNum, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.3, %sw.epilog
  br label %if.end.5

if.end.5:                                         ; preds = %if.end, %entry
  ret void
}

declare i32 @pthread_self(...)

; Function Attrs: nounwind uwtable
define internal void @snapshot64(i64 %gvar, i32 %index) {
entry:
  %gvar.addr = alloca i64, align 8
  %index.addr = alloca i32, align 4
  store i64 %gvar, i64* %gvar.addr, align 8
  store i32 %index, i32* %index.addr, align 4
  %0 = load i64* %gvar.addr, align 8
  %conv = trunc i64 %0 to i32
  %1 = load i32* %index.addr, align 4
  call void @snapshot(i32 %conv, i32 %1)
  ret void
}

define internal void @InitializeSwitchesAndCounter() {
entry:
  ret void
}

define internal void @IncrementCounter() {
entry:
  %idx = alloca i32, align 4
  %i = alloca i32, align 4
  %call = call i32 (...) *@pthread_self()
  store i32 %call, i32* %idx, align 4
  %0 = load i32* %idx, align 4
  %idxprom = zext i32 %0 to i64
  %arrayidx = getelementptr inbounds [3 x i32]* @syncID, i32 0, i64 %idxprom
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32* @counter0, align 4
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* @counter0, align 4
  %3 = load i8* @firstSync, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then.1, label %if.end

if.then.1:                                        ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.1
  %4 = load i32* %i, align 4
  %cmp2 = icmp slt i32 %4, 3
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32* %i, align 4
  %idxprom3 = sext i32 %5 to i64
  %arrayidx4 = getelementptr inbounds [3 x i8]* @switches, i32 0, i64 %idxprom3
  store i8 1, i8* %arrayidx4, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc5 = add nsw i32 %6, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i8 0, i8* @firstSync, align 1
  br label %if.end

if.end:                                           ; preds = %for.end, %if.then
  br label %if.end.7

if.else:                                          ; preds = %entry
  %7 = load i32* @counter1, align 4
  %inc6 = add nsw i32 %7, 1
  store i32 %inc6, i32* @counter1, align 4
  br label %if.end.7

if.end.7:                                         ; preds = %if.else, %if.end
  ret void
}

declare i32 @sleep(i32)



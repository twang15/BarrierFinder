Goal: wrap the code for a well-defined executable, including
a. all the variables, both sync variables and non-sync variables(such as loop index variables) are properly
   allocated. For stack variable, there should be a dominating alloc; for heap variable, there should be a
   dominateing malloc; for global variable, there should be global declaration.

b. all variables should be properly defined. All values are initialized properly before any usage happens.
   Essentially, though the interpretation happens in Cloud9, it is not symbolic execution but a flexible
   interpretation with scheduling enumeration, which requires there is no symbolic variable, i.e., variables
   are properly defined.

c. types information are kept properly.

d. control constructs should be complete, such as loop, function call, if-branch, etc.


Design analysis:
With two day's analysis, we have 3 possible implementation choices. The goal to compare them is to select
the one which involves least complexities but still satisfies the above goals.

1. Rewrite a basic block which contains all the alloc/malloc/initialization code and use it as the pre-condition
   BB to all the sync related code. The advantage is that it is intuitive(the same reason why I come up with it first).
   But, to keep the loop construct and call relation is unnecessarily more complicated. We also have to add many codes
   to analyze the sync variable and non-sync variables involved. And based on the analysis result, we will add the
   generative code for load/store/alloc/malloc operations, etc., to satisfy the "properly allocated and defined" goal.
   This process is tedious and very easy to be incomplete. Although there are tools, such as llvm2cpp to help, it is
   still overwhelmingly complex. Moreover, I need to extend intra-vrp to handle stack variable(loop index var i) before
   I can proceed to a quick result of our frontend. In contrast, the extension to intra-vrp can be skipped in Option 2
   because the value of i is implicitly kept by the intra-slice algorithm. If we really need the extension, I can add it
   afterwards.

2. Apply intra-slice in main. The biggest advantage is that slicing algorithm tracks all the alloc/malloc automatically
   and systematically. Besides, it also keeps the assignment(initialization/definition) implicitly, which seems to make
   intra-vrp meaningless because the definitions, if there are, will happen automatically during interpretation, for
   example, gsense and count. However, for P, which is input-dependent, there is no such benefit, which means the 
   preprocessing of value range/definition (verification/intra-vrp) is necessary, so that we still have a valid
   executable in the end. The intra-vrp can be applied on the intra-sliced main to verify whether variables are properly
   defined. If not, predicate analysis is necessary just as what has been done so far. This analysis assures that
   intra-vrp and predicate analysis is not useless but will be integrated into the final framework in some form and is
   an indispensable part.

   The intra-slice will keep the interactive loop for accepting user-input of P. This is nice because we can show that with
   little effort, the user can help reduce the complexity of our framework, especially reduce the run-time of interpretation
   because P will get more meaningful values, which can exclude values such as 3 and 5. This values can be generated by
   the predicate analysis alone.

   If we do not perform any value range analysis, we can add time-out mechanism into Cloud9 to terminate those execution which
   has symbolic value or deadlocks or too many schedulings. Note, the time-out mechanism can co-exist with value-range analysis.

3. inter-slice. Compared to 1 and 2, inter-slice is very natural and intuitive and seems to be the ideal solution. However, we
   did not choose this option in the beginning not because of ignorance but over-estimation. The biggest obstacle is that the
   classic Mark-Weiser Slicing algorithm (intra or inter) is for sequential program. The concurrent program slicing is a 
   challenging topics which have produced many research papers. I was about to read papers to understand their complexities but
   did not do it after discussion with Guoliang and Frank, because we thought intra-slice + intra-vrp is another seemingly simpler
   solution. So far, the complication introduced by concurrent program slicing is still valid. However, it is time to re-evaluate
   how complicated it is after we finished intra-slice + intra-vrp and analysis code-wrapping. Especially, since, option 2, compared to 
   option 1, is much easier, and is essentially intra-slice + intra-vrp + intra-slice, it makes me rethink of inter-slice as a more
   elegant, cleaner and unified approach. The problem with intra-vrp being not sound enough compared to inter-vrp brings more 
   motivations to the rethinking. The result is, if we add more assumptions, we can circumvent the complexity of concurrent program
   slicing. Since we have already assumed the read-side and write-side can happen concurrently, and there is certain order, we want
   to apply the inter-slice in different segments(call stack divided by pthread_create) and then stitch them together, just like
   what we are doing for option 2. There may be redundant information, such as that may appear in allAB of MySql (multiple invokation
   of thread entry function will be kept in main) and we need more heuristics. However, it is still interesting to see what we can
   get with this approach. Eventually, we want kept multiple sync constructs in the program and figure out their order relations.
   To achieve this ultimate goal, it seems only inter-slice is powerful and simple enough. The main drawback is that it will take
   longer to produce an executable for our frontend because I have to understand the algorithm, code and its implications to our
   current framework. Therefore, I tend to not choose it this time.

Design decision:

The major consideration of decision is to speedup the progress of frontend framework. We want to see what code the frontend 
will generate and how it interacts with Cloud9 so that we can further estimate the engineering effort and identify potential
challenges in Cloud9, which is critical for project planning.

Since 1 and 3 involves more complexities, we decide to choose 2.
But, we will re-evaluate 3's potential in the future.

Reference for option 1( llvm-IR generation in program)
1. ellcc (another llvm2cpp tool)
  http://ellcc.org/demo/index.cgi
  http://ellcc.org/blog/?page_id=467

2. llvm2cpp
  http://fdiv.net/2012/11/16/llvm-generates-code-that-generates-code
